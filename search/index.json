[{"content":"GitHubテンプレート roblox-ts-rojo-template\nこれは何？ Roblox（TypeScript）でVSCodeを使ったモダンな開発環境のテンプレートです。\nVSCode 👉 Roblox Studioへの同期: Rojo リンター: ESlint フォーマッター: Prettier パッケージマネージャー: pnpm ❗ Caution 動作未確認ですが、有名なパッケージを入れてあります。\n\u0026ldquo;@rbxts/janitor\u0026rdquo; \u0026ldquo;@rbxts/profileservice\u0026rdquo; \u0026ldquo;@rbxts/replicaservice\u0026rdquo; \u0026ldquo;@rbxts/cmdr\u0026rdquo; \u0026ldquo;@rbxts/testez\u0026rdquo; ℹ️ Note 動作確認済\n\u0026ldquo;@rbxts/react\u0026rdquo; \u0026ldquo;@rbxts/react-roblox\u0026rdquo; ℹ️ Warning CI/CDは入ってないです\nインストール 💡 Tip \u0026ldquo;Use this template\u0026quot;ボタンから使えます。\nパッケージのインストール 1 pnpm install VSCode拡張機能のインストール このプロジェクトを開くとVSCodeで以下の拡張機能が表示されるのでインストールします。\nroblox-ts ESLint Prettier Rojo 使い方 VSCodeからRojo 1 pnpm run watch 「Ctrl + Shift + P」\n「Rojo: Open Menu」\nℹ️ Note 初めてならRoblox Studioを起動して、Install Roblox Studio Plugin\n「▶ default.project.json」\nRoblox StudioからRojo 「プラグイン」タブ\n「Rojo」リボン\n「Connect」ボタン\n","date":"2025-06-22T00:00:00+09:00","image":"https://takoyakisoft.com/p/roblox-ts-template-for-modern-development/roblox-ts-template-for-modern-development_hu_a201222c2d03b0b2.webp","permalink":"https://takoyakisoft.com/p/roblox-ts-template-for-modern-development/","title":"Roblox（TypeScript）とVSCodeでモダンな開発環境のテンプレート"},{"content":"GitHubテンプレート roblox-rojo-wally-template\nこれは何？ Roblox（Luau）でVSCodeを使ったモダンな開発環境のテンプレートです。\nVSCode 👉 Roblox Studioへの同期: Rojo リンター: Selene フォーマッター: StyLua パッケージマネージャー: Wally RojoとWallyのマネージャー:　Rokit ℹ️ Warning CI/CDは入ってないです: CI/CD\nインストール 💡 Tip \u0026ldquo;Use this template\u0026quot;ボタンから使えます。\nRokitのインストール Windows (PowerShell)\n1 Invoke-RestMethod https://raw.githubusercontent.com/rojo-rbx/rokit/main/scripts/install.ps1 | Invoke-Expression macOS / Linux\n1 curl -fsSL https://raw.githubusercontent.com/rojo-rbx/rokit/main/scripts/install.sh | sh RojoやWallyなどのインストール 1 2 3 rokit add rojo rokit add wally rokit add wally-package-types パッケージのインストール 1 2 3 4 5 wally install rojo sourcemap default.project.json --output sourcemap.json wally-package-types -s sourcemap.json Packages/ wally-package-types -s sourcemap.json ServerPackages/ wally-package-types -s sourcemap.json DevPackages/ VSCode拡張機能のインストール このプロジェクトを開くとVSCodeで以下の拡張機能が表示されるのでインストールします。\nRojo Luau Language Server Selene StyLua 使い方 VSCodeからRojo 「Ctrl + Shift + P」\n「Rojo: Open Menu」\nℹ️ Note 初めてならRoblox Studioを起動して、Install Roblox Studio Plugin\n「▶ default.project.json」\nRoblox StudioからRojo 「プラグイン」タブ\n「Rojo」リボン\n「Connect」ボタン\nWallyにパッケージを追加 wally.tomlをVSCodeで編集します。\nwally.runのサイトで欲しいパッケージを調べて「Install」でパッケージ名をコピーします。\n各セクションの分類は\n[dependencies]がクライアントとサーバー\n[server-dependencies]がサーバーのみ\n[dev-dependencies]が開発やテストのみ\n書き終えたら、再度パッケージのインストールを行います。\n参考 How Big Studios Develop on Roblox\n","date":"2025-06-21T00:00:00+09:00","image":"https://takoyakisoft.com/p/roblox-luau-template-for-modern-development/roblox-luau-template-for-modern-development_hu_a201222c2d03b0b2.webp","permalink":"https://takoyakisoft.com/p/roblox-luau-template-for-modern-development/","title":"Roblox（Luau）とVSCodeでモダンな開発環境のテンプレート"},{"content":"こんにちは！\nちなみに、この記事もRovo Dev CLIのAIアシスタント機能を使って書いてるんですよ。便利ですよね！\n今回はAtlassianが作った開発AIエージェント「Rovo Dev CLI」について解説していこうと思います。\nこれは人気の「Claude Code」みたいなツールです。ターミナル上でAIとおしゃべりしながら、コーディングを手伝ってもらったり、テストを作ってもらったり、リファクタリングをお願いしたり、色々なことに使えます。しかも今はベータ期間中なので無料で利用できるんです。\nただ、WindowsのPowerShellでそのまま使うと、日本語が文字化けしちゃうんですよね…。\nでも大丈夫です！ この記事では基本的な使い方から、その文字化け問題を「WSL2」と「VSCode」を使って華麗に解決する方法、さらにはAIに3Dモデリングを指示できてしまう「MCP連携」まで、具体的な手順を交えてご紹介します。\nRovo Dev CLIって、なあに？ Rovo Dev CLIはJiraやConfluenceで有名なAtlassianが開発した、コマンドラインで使えるAIアシスタントです。\nRovo Dev本人に「どのモデルを使ってるの？」って聞いてみたら、Anthropic社のClaudeファミリーを使っているとのことでした。\nWindowsユーザーの方はまずここから！WSL2のセットアップ WindowsでRovo Dev CLIを使うなら、WSL2 (Windows Subsystem for Linux 2) を使うのが断然おすすめです。 さっきもお話しした通り、PowerShellで直接使うと日本語が文字化けしてしまうからなんです。\nWSL2のインストールと設定 WSL2のインストール 「PowerShell」を開いて、このコマンドを実行します。\n1 wsl --install -d Ubuntu-24.04 私の環境だと、一度PCを再起動しないとWSLがうまく起動しませんでした。もし動かなかったら試してみてください。\nWSL2の初期設定 インストールが終わるとUbuntuが起動するので、ユーザー名とパスワードを設定しましょう。\n便利なミラーモードネットワークの設定 WSL2の新しい機能「ミラーモード」を設定すると、WindowsとWSL2の間でネットワークが共有されて、どちらからでも「localhost」でアクセスできるようになります。 これが後で説明するMCP連携ですごく便利になるんです。\nWindowsのユーザーフォルダ（C:\\Users\\あなたのユーザー名）に.wslconfigっていうファイルを作って、以下の内容を書き込みます。\n1 2 [wsl2] networkingMode=mirrored メニューの「WSL Settings」からも同じことができますよ。\nWSL2の再起動 設定を反映させるために、PowerShellでこのコマンドを実行します。\n1 wsl --shutdown そのあと、WSL2（Ubuntu）をもう一度起動してくださいね。\nこれでWSL2の環境はバッチリです。 次のステップでは、VSCodeからこのWSL2環境につないで、もっと快適に操作できるようにしていきます。\nVSCodeからWSL2に接続しよう ここからの操作は、全部VSCodeのWSL拡張機能を使ってやっていきますね。\nVSCodeのWSL拡張機能のインストールと接続手順 VSCodeのインストール もし、まだインストールしていなかったら、公式サイトからダウンロードしてインストールしてください。\nWSL拡張機能のインストール VSCodeを起動して、左側にある拡張機能タブ（Ctrl+Shift+X）から「WSL」って検索してインストールします。\nWSL2に接続 VSCodeウィンドウの左下にある緑色のアイコンをクリックして、「ディストリビューションを使用してWSLに接続\u0026hellip;」を選びます。 Ubuntu-24.04を選択 さっきインストールしたUbuntu-24.04を選択します。\nターミナルを開く VSCodeのメニューから「ターミナル」→「新しいターミナル」を選ぶか、ショートカットキーのCtrl+`を押してターミナルを開きます。 画像みたいに開いてもOKです。 これで、VSCodeからWSL2のUbuntuにアクセスする準備はOKです！ これからの操作は、このVSCode上のターミナルでやっていきましょう。 ファイルの編集や作成も、VSCodeのエディタが使えるのでとっても楽ちんですよ。\nインストールと最初のセットアップ ACLI (Atlassian CLI) のインストール Rovo Devは、ACLIっていうAtlassianの共通ツール経由で使います。まずはこれをWSL2のUbuntuにインストールしていきましょう。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 必要なパッケージをインストールします sudo apt-get install -y wget gnupg2 # APTリポジトリの設定をします # 鍵の保存先ディレクトリを作成 sudo mkdir -p -m 755 /etc/apt/keyrings # 公開鍵をダウンロードしてGPG形式に変換 wget -nv -O- https://acli.atlassian.com/gpg/public-key.asc | sudo gpg --dearmor -o /etc/apt/keyrings/acli-archive-keyring.gpg # 鍵ファイルの権限を設定 sudo chmod go+r /etc/apt/keyrings/acli-archive-keyring.gpg # リポジトリ情報をAPTの設定に追加 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/acli-archive-keyring.gpg] https://acli.atlassian.com/linux/deb stable main\u0026#34; | sudo tee /etc/apt/sources.list.d/acli.list \u0026gt; /dev/null # ACLIをインストールします sudo apt update sudo apt install -y acli もし他のOSを使っている場合は、公式サイトのInstall and updateに手順がありますよ。\nAtlassian APIトークンの取得と認証 次に、AtlassianアカウントでログインするためのAPIトークンをもらいにいきましょう。\nAtlassian IDのプロファイルにアクセスします。 「Create API token」をクリックして、わかりやすい名前（例えば rovo-dev-cli とか）をつけてトークンを作ります。 生成されたトークンは一度しか表示されないので、必ずコピーしてどこかにメモしておいてくださいね！ トークンが準備できたら、ターミナルでこのコマンドを実行して認証します。\n1 acli rovodev auth login メールアドレスと、さっきコピーしたAPIトークンを貼り付ければ認証完了です。\n起動！ さあ、いよいよAIエージェントを起動します。\n1 acli rovodev run これを実行すると、ターミナルがAIとの対話モードに切り替わります。ワクワクしますね！\n知っておくと便利！基本的な使い方 Rovo Dev CLIには、開発がぐっと楽になる機能がたくさんあります。\nカスタムプロンプト（カスタムインストラクション） 毎回同じことをお願いするのって、ちょっと面倒ですよね。そういう時に便利なのが、このカスタムプロンプト機能です。AIにあらかじめ前提知識を教えておけるんですよ。Claudeのデスクトップ版にあるCLAUDE.mdみたいな感じで設定できます。\n設定方法は3種類あります。\nグローバル設定ファイル ~/.rovodev/config.yml にこんな感じで書きます。PC全体で有効な指示ですね。 1 2 3 4 additionalSystemPrompt: | あなたはPythonとTypeScriptの専門家です。 コードを書く際は、常にテストを含めてください。 説明は簡潔に、日本語で行ってください。 グローバルエージェントファイル ~/.rovodev/.agent.md というファイルに、AIに読み込ませたい指示を書きます。Markdown形式なので、もっと詳しく書けますよ。 1 2 3 4 5 6 7 8 9 10 # 開発者向けガイドライン ## コーディングスタイル - インデントは2スペースを使用する - 関数名はcamelCaseで記述する - クラス名はPascalCaseで記述する ## テスト方針 - ユニットテストは必須 - モックを活用してテストを高速化する プロジェクト固有の指示 作業しているリポジトリのルートに .agent.mdファイルを作ります。これはチームで共有するルールを書くのに便利です。個人的な設定は .agent.local.md に書いておけば、Gitの管理対象外にできるのでおすすめです。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # プロジェクト固有のガイドライン このプロジェクトは、Next.jsとTypeScriptを使用したWebアプリケーションです。 ## アーキテクチャ - pages/ - ルーティング用のページコンポーネント - components/ - 再利用可能なUIコンポーネント - lib/ - ユーティリティ関数やヘルパー - styles/ - CSSモジュールとグローバルスタイル ## 開発ルール - コンポーネントは関数コンポーネントで作成する - 状態管理にはReact Hooksを使用する - APIリクエストはSWRを使用する これらの設定は全部組み合わせて使えるので、AIはすべての指示を考慮して答えてくれます。効果的なカスタムインストラクションを書くことで、AIからもっと質の高い回答がもらえるようになりますよ。\nコマンドの例 対話モードでは、こんな風にお願いできます。\nsummarize this file ./path/to/file.js: このファイルを要約して！ add unit tests for UserService: UserServiceのユニットテストを書いて！ Refactor this complex function to be more readable: この複雑な関数を読みやすく書き直して！ AIがディレクトリの構造をちゃんと理解してくれるので、ファイルパスを渡すだけで文脈を読み取ってくれるのが賢いところですね。\n対話モードの便利なコマンド一覧 対話モードには、他にも便利なコマンドがいっぱいあります。AIとのやりとりがもっとスムーズになりますよ。もしコマンドの詳しい使い方が知りたくなったら、対話モードで /コマンド名 help と入力してみてください。\nセッション管理 /sessions セッションを管理するコマンドです。これを使うと、会話の履歴や文脈を別々に分けておけるのですごく便利ですよ。\n主な機能: セッション管理: 複数の会話セッションを作ったり、切り替えたりできます。 コンテキスト保持: 各セッションは、それぞれ独自の会話履歴を覚えています。 ワークスペース分離: プロジェクトごとにセッションを分けられます。 セッションのフォーク: 今の会話から分岐して、新しいセッションを作ることも可能です。 Rovo Dev CLIを再起動するときに --restore っていうオプションをつけると、前のセッションを自動で復元してくれます。\nセッションのクリア /clear 今のセッションの会話履歴を全部消して、まっさらな状態に戻します。この操作は元に戻せないので注意してくださいね。履歴を残しておきたい場合は、/sessions コマンドで新しいセッションを作るか、次に紹介する /prune コマンドを使いましょう。\nセッションの最適化 /prune 会話が長くなってきたなって時に使います。大事なところは残しつつ、トークンを節約してくれる賢いコマンドです。AIが実行したツール（プログラム）の結果とかを削除して、履歴をスリムにしてくれます。\n事前定義された指示テンプレート /instructions コードレビューとかドキュメント作成みたいによくある作業のために、あらかじめ用意された指示のテンプレートを実行できます。\n組み込みの指示テンプレート: コードレビューと分析 ドキュメント生成と改善 ユニットテスト作成とカバレッジ改善 Confluenceページの要約 Jira課題の分析 自分でカスタムテンプレートも作れますよ！\n.rovodev/instuctions.yml に指示ファイルを作成します。 .rovodev フォルダの中に、指示の内容を書いたMarkdownファイルを作ります。 使い方は簡単で、/instructionsと打つとテンプレートの一覧が出てきます。\nメモリ管理 /memory プロジェクトや設定に関する大事な情報を、Rovo Dev CLIに覚えておいてもらうための機能です。\nメモリの種類: プロジェクトメモリ: 今いるディレクトリに保存されます。（.agent.md と .agent.local.md） ユーザーメモリ: ホームディレクトリにグローバルに保存されます。（~/.rovodev/agent.md） メモリファイルはMarkdown形式で、プロジェクトのルールやコーディングの決まり事などを書いておくと便利です。 # メモしたいことみたいに書くと、さっとメモを追加できますよ。\nフィードバック /feedback Rovo Dev CLIについての感想やバグ報告を送るためのコマンドです。\n使用状況 /usage 今日のLLMトークン使用量を確認できます。使いすぎてないかチェック！\n終了 /exit アプリケーションを終了します。/quitや/qでも同じです。\n【応用編】WSL2とWindows間の連携 VSCodeのWSL拡張機能のおかげで、WSL2とWindowsの間のファイル共有やアプリ連携がすごくスムーズになります。\nミラーモードネットワークの活用 最初に設定したWSL2のミラーモードネットワーク、これが大活躍します。\nポートの共有: WSL2で立ち上げたサーバー（例えば localhost:3000）に、Windowsのブラウザから直接アクセスできます。 ネットワークサービスの共有: WindowsとWSL2の両方から、同じネットワーク上のサービスを使えます。 MCPサーバーとの連携: この機能が、次で説明するMCP連携で特に重要になります。WSL2のRovo Dev CLIから、Windowsで動いているBlenderのMCPサーバーにシームレスに接続できるようになるんです。 この連携のおかげで、Windowsの使いやすい画面と、Linuxのパワフルなコマンドラインのいいとこどりができるんですよ。\n【応用】MCPでBlenderをAIに操作させてみよう！ いよいよ仕上げです！Rovo Devの強力な機能、MCP (Model Context Protocol) を使って、WSL2からWindows上のBlenderを動かしてみましょう。今回はBlenderMCPという便利なオープンソースツールを使わせてもらいます。\nBlenderMCPって何？ BlenderMCPはAIとBlenderをつないでくれるツールです。これを使うと、AIがBlenderを直接操作して、3Dモデリングやシーン作成、オブジェクトの操作なんかをやってくれるようになるんです！\n主な機能\n双方向通信: AIとBlenderを接続します オブジェクト操作: モノを作ったり、動かしたり、消したりできます マテリアル制御: 色を塗ったり、質感を設定したりできます シーン検査: 今Blenderで何がどうなっているかAIが確認できます コード実行: AIからBlenderにPythonコードを送って実行させられます セットアップ手順 BlenderMCPは2つの部品でできています。\nWindows側: Blenderアドオン (addon.py): WindowsのBlenderにインストールします WSL2側: MCPサーバー: WSL2のUbuntuにインストールして、Rovo Dev CLIから使います では、セットアップしていきましょう！\nWindows側: Blenderアドオンのインストール\nBlenderMCPのGitHubリポジトリからaddon.pyをダウンロードします Blenderを開いて、「編集」\u0026gt;「プリファレンス」\u0026gt;「アドオン」と進みます 「ディスクからインストール\u0026hellip;」をクリックして、ダウンロードしたaddon.pyファイルを選びます 「Blender MCP」の横にあるチェックボックスをオンにして、アドオンを有効にします WSL2側: uvパッケージマネージャーのインストール\nWSL2のUbuntuターミナルで、このコマンドを実行します 1 2 # uvパッケージマネージャーをインストール curl -LsSf https://astral.sh/uv/install.sh | sh WSL2側: Rovo Dev CLIの設定\nVSCodeを使って設定ファイルを編集しましょう 1 2 export EDITOR=\u0026#34;code\u0026#34; acli rovodev mcp するとVSCodeで設定ファイルが開くので、以下の内容を追加します。これはRovo Dev CLIが起動するときに自動でBlenderMCPも動かすための設定です 1 2 3 4 5 6 7 8 { \u0026#34;mcpServers\u0026#34;: { \u0026#34;blender\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;uvx\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;blender-mcp\u0026#34;] } } } Windows側: Blenderでの接続設定\nBlenderの画面で、3Dビューのサイドバーを開きます（もし表示されていなければNキーを押してください） 「BlenderMCP」というタブを見つけて、「Connect to MCP server」をクリックします WSL2側: Rovo Dev CLIでBlenderを操作！\nWSL2のVSCode統合ターミナルで acli rovodev run を実行します AIにこんな風にお願いしてみましょう 1 Blenderを使って、猫を作成してください。 するとどうでしょう！WSL2からの指示で、Windowsで起動しているBlenderの画面に立方体が現れ、スッと上に移動したりするはずです。これが最初に設定したミラーモードネットワークの力なんですね。WSL2は、Windowsで動いているBlenderを「localhost上のサーバー」として認識して、シームレスに連携できちゃうんです。すごい！\nMCPのトラブルシューティング もしうまく動かない場合は、こんなところを確認してみてください。\n接続の問題: Blenderのアドオンは有効になっていますか？BlenderのMCPタブで「Connect to MCP server」をクリックしましたか？ WSL2のミラーモードネットワーク: ミラーモードがちゃんと有効になっているか確認してみてください 再起動してみる: 接続エラーが続くようなら、Rovo Dev CLIとBlenderの両方を再起動してみるのが手っ取り早いかもしれません コマンドの実行方法: uvx blender-mcpコマンドは直接実行しないでくださいね。Rovo Dev CLIが設定ファイルをもとに自動で実行してくれます 一番大事なのは、WSL2とWindowsの間のネットワーク接続がミラーモードで正しく設定されていることです。\nまとめ 今回はAtlassianの新しいAI開発ツール「Rovo Dev CLI」の基本的な使い方から、Windowsユーザーが快適に使うためのWSL2活用術、そしてMCPを使ったBlender連携まで、幅広くご紹介しました。\n最初は少し設定が必要で大変かもしれませんが、一度環境を整えてしまえば、ターミナルから一歩も出ずにAIの強力なサポートを受けられる開発体験は本当に革命的だと思います。\nRovo Dev CLIはまだベータ版なので、これからどんどん進化していくのが楽しみですね。 この記事が皆さんの新しい開発スタイルを見つける手助けになれば嬉しいです。\nぜひこの未来のツールを試してみてくださいね。Happy coding! 🎉\n","date":"2025-06-19T15:05:00+09:00","image":"https://takoyakisoft.com/p/rovo-dev-cli-guide-wsl2-blender/rovo-dev-cli-guide-wsl2-blender_hu_79a0b353e74edfc1.webp","permalink":"https://takoyakisoft.com/p/rovo-dev-cli-guide-wsl2-blender/","title":"Rovo Dev CLI実践ガイド：VSCodeとWSL2で快適に使う方法"},{"content":"こんにちは！今回は、mastraっていうライブラリを使って、Grok-2とGemini 2.5 Pro expなどのLLMを動かしてみたお話です。\nmastraは、プロンプトを使うLLMを決めて「AIエージェント」を作って、それらをどういう順番で動かすかの「ワークフロー」を組めるライブラリです。TypeScriptで書けるっていうのが個人的には嬉しいポイントで、これならCloudflare WorkersとかDenoみたいな環境で、安価にWebサービスに組み込めるかもしれないなと思ってます。\n似たようなライブラリだとLangChainとか有名ですけど、mastraはデプロイのしやすさでちょっと有利かもしれませんね。あと、以前試したDifyっていうツールが、繰り返し処理（ループ）が少し苦手な感じだったので、mastraならどうかな？と思って試してみた、という背景もあります。\nでは、さっそく試していきましょう！\nmastraのインストール 今回はWindows 11で、AIエディターの「Trae」と、高速なパッケージマネージャー「pnpm」を使ってみます。\nまずは、mastraの公式サイトにある手順でプロジェクトを作っていきます。 （参考: Create a New Project）\nターミナルを開いて、次のコマンドを実行します。\n1 pnpm create mastra@latest いくつか質問されるので、答えていきましょう。\nプロジェクト名を聞かれます。今回はmy-mastra-appにしました。\n1 2 ◇ What do you want to name your project? │ my-mastra-app ソースファイルを置く場所ですね。デフォルトのsrc/でOKです。\n1 2 ◆ Where should we create the Mastra files? (default: src/) │ src/ 必要なコンポーネントを選びます。Agents（エージェント）、Workflows（ワークフロー）とTools（ツール）は後で使うので、Yesを選んでおきましょう。\n1 2 3 4 5 ◆ Choose components to install: │ ◼ Agents │ ◼ Workflows ◇ Add tools? │ Yes デフォルトで使うLLMプロバイダーを選びます。今回はGoogleを選んでみましたが、これは後で自由に変更できます。\n1 2 ◇ Select default provider: │ Google APIキーの設定です。あとで.env.developmentファイルに設定するので、ここではスキップ（Skip for now）で大丈夫です。\n1 2 ◆ Enter your google API key? │ ● Skip for now (default) サンプルの追加は、今回はYesにします。\n1 2 ◇ Add example │ Yes AI IDEとの連携も、今回はスキップしました。\n1 2 ◇ Make your AI IDE into a Mastra expert? (installs Mastra docs MCP server) │ Skip for now これでプロジェクトの雛形ができました！ 作成されたプロジェクトのフォルダに移動して、必要なライブラリをインストールします。\n1 2 cd my-mastra-app pnpm i 開発用のサーバーを起動してみましょう。Ctrl+Cで止められます。\n1 pnpm run dev 設定を見てみよう インストールが終わったら、いくつかファイルを見てみましょうか。\npackage.jsonを見ると、dependenciesに@ai-sdk/googleが入ってますね。これはVercel社が提供しているライブラリで、GeminiだけじゃなくてDeepSeekやGrok、OpenRouterみたいな他のLLMプロバイダーにも対応しているみたいです。便利そうですね！ （参考: AI SDK Providers）\nscriptsにはdevしかないです。これは今後、ビルドとかテスト用のスクリプトが追加されるのかもしれません。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;name\u0026#34;: \u0026#34;my-mastra-app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;mastra dev\u0026#34; }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;@ai-sdk/google\u0026#34;: \u0026#34;^1.2.5\u0026#34;, \u0026#34;@mastra/core\u0026#34;: \u0026#34;^0.7.0\u0026#34;, \u0026#34;mastra\u0026#34;: \u0026#34;^0.4.4\u0026#34;, \u0026#34;zod\u0026#34;: \u0026#34;^3.24.2\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/node\u0026#34;: \u0026#34;^22.14.0\u0026#34;, \u0026#34;tsx\u0026#34;: \u0026#34;^4.19.3\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^5.8.2\u0026#34; } } 今回はxAIのGrokも使いたいので、対応するライブラリを追加します。\n1 pnpm add @ai-sdk/xai もし不要になったら、pnpm remove @ai-sdk/xaiで消せます。\n次にAPIキーの設定です。プロジェクトのルートに.env.developmentと.envというファイルを作って、それぞれのAPIキーを記述します。（.envは本番用、.env.developmentは開発用です）\n.env.development:\n1 2 GOOGLE_GENERATIVE_AI_API_KEY=your-google-api-key XAI_API_KEY=your-xai-api-key LLMのモデルを変更したい場合は、エージェントを定義しているファイル（例えば src/mastra/agents/index.ts）とか、ワークフローのファイル（例えば src/mastra/workflows/index.ts）で指定します。\n例えば、Grok-2を使う場合はこんな感じです。\nsrc/mastra/agents/index.ts の例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { xai } from \u0026#39;@ai-sdk/xai\u0026#39;; // xAIのライブラリをインポート import { Agent } from \u0026#39;@mastra/core/agent\u0026#39;; import { weatherTool } from \u0026#39;../tools\u0026#39;; // 使うツールもインポート export const weatherAgent = new Agent({ name: \u0026#39;Weather Agent\u0026#39;, instructions: ` You are a helpful weather assistant that provides accurate weather information. Your primary function is to help users get weather details for specific locations. When responding: - Always ask for a location if none is provided - If the location name isn’t in English, please translate it - If giving a location with multiple parts (e.g. \u0026#34;New York, NY\u0026#34;), use the most relevant part (e.g. \u0026#34;New York\u0026#34;) - Include relevant details like humidity, wind conditions, and precipitation - Keep responses concise but informative Use the weatherTool to fetch current weather data. `, model: xai(\u0026#39;grok-2-latest\u0026#39;), // ここでモデルを指定！ tools: { weatherTool }, }); ワークフロー内でも同様に指定できます。\nsrc/mastra/workflows/index.ts の例:\n1 2 3 4 5 6 import { xai } from \u0026#39;@ai-sdk/xai\u0026#39;; import { Agent } from \u0026#39;@mastra/core/agent\u0026#39;; import { Step, Workflow } from \u0026#39;@mastra/core/workflows\u0026#39;; import { z } from \u0026#39;zod\u0026#39;; const llm = xai(\u0026#39;grok-2-latest\u0026#39;); // ここで使うモデルを定義 動作確認してみよう 設定ができたら、もう一度開発サーバーを起動してみましょう。\n1 pnpm run dev ブラウザで http://localhost:4111/にアクセスすると、mastraのインターフェースが表示されるはずです。\nエージェントを選んで、チャット形式で試せますね。\nGrok-2を使うと、答えが英語で返ってくることがあります。\n「thinkツール」を実装してみる 次に、ちょっと面白いツールを実装してみます。「thinkツール」っていうものです。\nこれは、Anthropicの記事で紹介されていたテクニックで、LLMに何かを実行させる前に「考えさせる」ステップを入れると性能が上がる、というものらしいです。 （参考: The \u0026ldquo;think\u0026rdquo; tool: Enabling Claude to stop and think in complex tool use situations）\nこのツール自体は、特に何か外部の情報を持ってきたりするわけではなくて、ただ「考える」というプロセスを模倣させるだけなんです。でも、これで複雑な推論とかが必要な場合に効果があるみたいです。面白いですよね！\nでは、mastraでthinkツールを作ってみましょう。\nまず、ツールを定義するファイルを作ります。\nsrc/mastra/tools/thinkTool.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { createTool } from \u0026#39;@mastra/core/tools\u0026#39;; import { z } from \u0026#39;zod\u0026#39;; // 入力データのバリデーション用 export const thinkTool = createTool({ id: \u0026#39;think\u0026#39;, // ツールのID description: \u0026#39;Use the tool to think about something. It will not obtain new information or change the database, but just append the thought to the log. Use it when complex reasoning or some cache memory is needed.\u0026#39;, // ツールの説明 inputSchema: z.object({ // ツールが受け取る入力の定義 thought: z.string().describe(\u0026#39;A thought to think about.\u0026#39;), }), outputSchema: z.object({}), // ツールが出力するデータの定義 (今回は空) execute: async ({ context }) =\u0026gt; { // 実際の処理は何もしない console.log(\u0026#39;Thinking:\u0026#39;, context.thought); // コンソールに思考内容を出すくらいはしてもいいかも return {}; }, }); 次に、このthinkツールを使うエージェントを作成します。プロンプトで、いつthinkツールを使うべきかを指示するのがポイントですね。\nsrc/mastra/agents/thinkAgent.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { Agent } from \u0026#39;@mastra/core/agent\u0026#39;; import { thinkTool } from \u0026#39;../tools/thinkTool\u0026#39;; // 作成したthinkToolをインポート import { xai } from \u0026#39;@ai-sdk/xai\u0026#39;; // 使うLLMモデルもインポート export const thinkAgent = new Agent({ name: \u0026#39;Think Agent\u0026#39;, instructions: ` ## Using the think tool Before taking any action or responding to the user after receiving tool results, use the think tool as a scratchpad to: - List the specific rules that apply to the current request - Check if all required information is collected - Verify that the planned action complies with all policies - Iterate over tool results for correctness Here are some examples of what to iterate over inside the think tool: \u0026lt;think_tool_example_1\u0026gt; User wants to [specific scenario] - Need to verify: [key information] - Check relevant rules: [list rules] - Verify [important conditions] - Plan: [outline steps] \u0026lt;/think_tool_example_1\u0026gt; ## Think in English and answer in Japanese `, // 日本語で答えてもらうように指示を追加！ model: xai(\u0026#39;grok-2-latest\u0026#39;), // ここもGrok-2にしてみましょう tools: { thinkTool } // このエージェントが使うツールとして登録 }); 最後に、作成したツールとエージェントをmastraに登録します。\nsrc/mastra/index.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Mastra } from \u0026#39;@mastra/core/mastra\u0026#39;; import { createLogger } from \u0026#39;@mastra/core/logger\u0026#39;; import { weatherWorkflow } from \u0026#39;./workflows\u0026#39;; import { weatherAgent } from \u0026#39;./agents\u0026#39;; import { thinkAgent } from \u0026#39;./agents/thinkAgent\u0026#39;; // 作成したthinkAgentをインポート export const mastra = new Mastra({ workflows: { weatherWorkflow }, // 既存のワークフロー agents: { weatherAgent, thinkAgent }, // エージェントを追加 logger: createLogger({ name: \u0026#39;Mastra\u0026#39;, level: \u0026#39;info\u0026#39;, }), }); これでthinkツールの実装は完了です！\nthinkツールの動作確認 再度、開発サーバーを起動して確認してみましょう。\n1 pnpm run dev http://localhost:4111/にアクセスして、今度は「Think Agent」を選んでみてください。\n何か指示を出すと、裏側でthinkツールが動いて、その後に応答してくれるはずです。\nこれで、少し複雑なことでも、より正確に考えてくれるようになったかもしれません！\n文章をクローンするプロンプトを作成するワークフローを実装してみる さて、ここからはmastraのループ機能と評価機能を組み合わせた、ちょっと応用的なワークフローに挑戦してみましょう！\nこのワークフローで目指すこと：AIに「自分の文体」を学習させる テーマは「与えられた文章の書き方を真似するAIプロンプトを、AI自身に作らせる」です。なんだかAIにAIの使い方を考えさせるみたいで、面白い試みだと思いませんか？\n最近、「AIが書いた文章か、人間が書いた文章か、見分けがつかない！」なんて話もよく聞きますよね。それなら、いっそ自分の文章のクセをAIに学習させて、ブログ記事の下書きとかを作ってもらえたら、タイピング量が減って楽になるんじゃないか？と思ったのが、このワークフローを作ってみたきっかけです。\n準備：評価ライブラリの追加とワークフロー登録 まずは準備：評価ライブラリの追加\nこのワークフローでは、生成されたプロンプトの良し悪しを別のAIに評価させるために、mastraの評価用ライブラリを使います。ターミナルで以下を実行してインストールしましょう。\n1 pnpm add @mastra/evals ワークフローをmastraに登録\n次に、これから作成するワークフロー (clonePromptGeneratorWorkflow) をmastra本体に認識させるため、設定ファイル (src/mastra/index.ts) を更新します。\nsrc/mastra/index.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Mastra } from \u0026#39;@mastra/core/mastra\u0026#39;; import { createLogger } from \u0026#39;@mastra/core/logger\u0026#39;; import { weatherWorkflow } from \u0026#39;./workflows\u0026#39;; // ↓ 新しいワークフローをインポート import { clonePromptGeneratorWorkflow } from \u0026#39;./workflows/clonePromptGeneratorWorkflow\u0026#39;; import { weatherAgent } from \u0026#39;./agents\u0026#39;; import { thinkAgent } from \u0026#39;./agents/thinkAgent\u0026#39;; export const mastra = new Mastra({ // ↓ workflowsオブジェクトに新しいワークフローを追加 workflows: { weatherWorkflow, clonePromptGeneratorWorkflow }, agents: { weatherAgent, thinkAgent }, logger: createLogger({ name: \u0026#39;Mastra\u0026#39;, level: \u0026#39;info\u0026#39;, }), }); これで準備OKです！\nAIがプロンプトを改善していく仕組み：処理フローを解説 では、実際にどんな流れでAIがプロンプトを生成・改善していくのかを見ていきましょう。\nプロンプト作成AI (Prompt Creator Agent): まず、あなたが用意した「お手本」となる文章（originalText）を分析させます。そして、その文章の書き手の特徴（人格、文体、口癖など）を捉えて、他のAIに「この人になりきって文章を書いてね！」と指示するための「なりきり指示プロンプト」の初版を作成します。\nテーマ抽出AI (Theme Abstractor Agent): 次に、お手本文章から具体的な固有名詞（mastra、Grok-2など）を取り除き、「ソフトウェアツールキットを使ってAI処理の流れを作る手順」のような、一般的な「抽象化テーマ」を抽出します。これは、なりきり具合をテストする際に、お手本と全く同じ内容になってしまわないようにするためです。\n文章生成AI (Text Generator Agent): ステップ1で作った「なりきり指示プロンプト」と、ステップ2で抽出した「抽象化テーマ」を使って、実際になりきり文章を生成させます。「『抽象化テーマ』について、なりきり指示プロンプトに従って書いてみて」という感じです。\n評価AI (Authorship Similarity Judge/Metric): いよいよ評価です。お手本文章と、ステップ3でAIが生成したなりきり文章を比較させ、「書き方の類似度」を0.0（全然似てない）から1.0（瓜二つ！）のスコアで採点します。単語選び、文の長さ、口調、句読点の使い方など、あくまで「書き方」だけを見て、内容の正しさは問いません。\nループ判定 \u0026amp; フィードバック:\n評価スコアが、あらかじめ設定した閾値（コード内では SIMILARITY_THRESHOLD = 0.7 としています）を超えていれば、「合格！」としてワークフローは終了し、成功した「なりきり指示プロンプト」を出力します。 スコアが閾値に満たなければ、「もっと頑張りましょう」となります。評価AIが「なぜスコアが低いのか（例: もっと句読点の使い方が似ていない、口調が硬すぎるなど）」を指摘したフィードバックを作成し、そのフィードバックを添えてステップ1のプロンプト作成AIに「このフィードバックを参考に、もっと良いプロンプトを作って！」と指示を出し、ループします。 このループを繰り返すことで、AIが試行錯誤しながら、どんどんお手本の書き方に近い文章を生成できるような「なりきり指示プロンプト」へと改善していく、という仕組みです。\nTips:\nモデル選択: 今回のコードでは xai('grok-2-latest') を使っていますが、もしGoogle AI Studioなどでアクセスできるなら gemini('gemini-2.5-pro-exp-03-25') のような、より高性能なモデルを試してみると、1回のループでかなり良い結果が出るかもしれません！ 各AgentやMetricの model: llm の部分を書き換えてみてください。 類似度スコアの閾値: SIMILARITY_THRESHOLD の値 (0.7) は、どれくらい厳しく評価するかの基準です。なかなかループが終わらない場合は少し下げてみたり、もっと精度を高めたい場合は上げてみたりと、手動で調整してみてください。 動かしてみよう！ワークフローの実行手順 開発サーバー (pnpm run dev) を起動した状態で、ブラウザから http://localhost:4111/ にアクセスします。\n左側のメニューから「Workflows」を選び、今回作成した clone-prompt-generator-workflow-with-eval を選択します。\n右側の「Run」というタブに OriginalText という入力フィールドが表示されるはずです。ここに、あなたがお手本にしたい文章（例えば、過去に書いたブログ記事の一部など）を貼り付けます。\n文章を貼り付けたら、「Submit」ボタンをクリック！\nあとは、ターミナル（またはVS CodeなどのOUTPUTパネル）に流れるログを見守りましょう。ループが回るたびに、評価スコアやフィードバックが表示されるはずです。\nワークフロー全体のコード 実際に動作するワークフローのコードは以下のようになります。\nsrc/mastra/workflows/clonePromptGeneratorWorkflow.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 import { xai } from \u0026#39;@ai-sdk/xai\u0026#39;; // or use gemini, openai, etc. // import { gemini } from \u0026#39;@ai-sdk/google\u0026#39;; // Geminiを使う場合の例 import { Agent } from \u0026#39;@mastra/core/agent\u0026#39;; import { Step, Workflow } from \u0026#39;@mastra/core/workflows\u0026#39;; import { z } from \u0026#39;zod\u0026#39;; import { type LanguageModel } from \u0026#39;@mastra/core/llm\u0026#39;; import { MastraAgentJudge } from \u0026#39;@mastra/evals/judge\u0026#39;; import { Metric, type MetricResult } from \u0026#39;@mastra/core/eval\u0026#39;; // --- 設定 --- // 使用するLLMモデル (必要に応じて変更) const llm = xai(\u0026#39;grok-2-latest\u0026#39;); // const llm = gemini(\u0026#39;gemini-2.5-pro-exp-03-25\u0026#39;); // Gemini 2.5 Pro Experimentalを使う場合の例 // 同一人物と判定する類似度スコアの閾値 (調整可能) const SIMILARITY_THRESHOLD = 0.7; // プロンプト作成AIへのフィードバックを格納する変数 let feedbackForPromptCreator = \u0026#34;\u0026#34;; // ループのカウンタ let iteration = 0; // --- 評価関連の定義 --- /** * 評価AIに渡すプロンプトを生成する関数 */ const generateSimilarityPrompt = ({ originalText, generatedText, }: { originalText: string; generatedText: string; }) =\u0026gt; ` あなたは、文章の書き方を比較分析する専門家です。 与えられた「お手本の文章」と「AIが生成した文章」を比較し、両者が**同じ人物によって書かれたように見えるか**どうかを評価してください。 **評価基準:** 以下の要素に着目し、総合的な書き方の類似度を判断してください。 * **文体:** 一人称、口調（丁寧語、タメ口など）、語尾（〜です、〜だ、〜よね等） * **単語選び:** 好んで使う単語、言い回し、専門用語の使用頻度 * **文章構成:** 文の長さ、段落の使い方、接続詞の使い方、論理展開 * **リズム・テンポ:** 句読点の使い方、体言止めの頻度 * **感情表現:** ポジティブ/ネガティブ、感情の表し方、ユーモアの有無 * **癖:** 特徴的な言い回し、誤字脱字の傾向（もしあれば） **重要:** トピックや内容の正しさではなく、あくまで**書き方**の類似性のみを評価してください。 **出力形式:** 以下のJSON形式で、評価結果を返してください。 * \\`similarityScore\\`: 書き方の類似度を 0.0 (全く似ていない) から 1.0 (完全に同じ人物に見える) の間の**数値**で評価してください。 * \\`reason\\`: なぜそのスコアになったのか、具体的な理由を簡潔に説明してください。特にスコアが低い場合は、どの点が異なると感じたかを指摘してください。 \\`\\`\\`json { \u0026#34;similarityScore\u0026#34;: number (0.0 ~ 1.0), \u0026#34;reason\u0026#34;: string } \\`\\`\\` --- **お手本の文章:** \\`\\`\\` ${originalText} \\`\\`\\` --- **AIが生成した文章:** \\`\\`\\` ${generatedText} \\`\\`\\` --- 上記の形式に従って、評価結果をJSONで出力してください。 `; /** * 評価結果の型定義 (zodスキーマ) */ const SimilarityEvaluationSchema = z.object({ similarityScore: z.number().min(0).max(1).describe(\u0026#34;書き方の類似度スコア (0.0から1.0)\u0026#34;), reason: z.string().describe(\u0026#34;評価の理由\u0026#34;), }); type SimilarityEvaluation = z.infer\u0026lt;typeof SimilarityEvaluationSchema\u0026gt;; /** * 評価者 (Judge) クラス */ class AuthorshipSimilarityJudge extends MastraAgentJudge { constructor(model: LanguageModel) { super( \u0026#39;Authorship Similarity Judge\u0026#39;, \u0026#39;あなたは文章の書き方を比較分析する専門家です。与えられた指示に従って、二つの文章の類似度を評価してください。\u0026#39;, model ); } async evaluate(originalText: string, generatedText: string): Promise\u0026lt;SimilarityEvaluation\u0026gt; { const prompt = generateSimilarityPrompt({ originalText, generatedText }); // JSONモードやスキーマ強制がモデルでサポートされていれば活用 try { const result = await this.agent.generate(prompt, { output: SimilarityEvaluationSchema }); return result.object; } catch (error) { console.error(\u0026#34;評価結果のパースに失敗しました。生テキストを返します。\u0026#34;, error); // フォールバック: JSONパースに失敗した場合、スコア0として扱うなど const fallbackResult = await this.agent.generate(prompt); return { similarityScore: 0.0, reason: `評価AIの出力形式が不正でした: ${fallbackResult.text}` }; } } } /** * 評価メトリクス (Metric) クラス */ interface AuthorshipSimilarityMetricResult extends MetricResult { info: SimilarityEvaluation; } class AuthorshipSimilarityMetric extends Metric { private judge: AuthorshipSimilarityJudge; constructor(model: LanguageModel) { super(); this.judge = new AuthorshipSimilarityJudge(model); } async measure(originalText: string, generatedText: string): Promise\u0026lt;AuthorshipSimilarityMetricResult\u0026gt; { const evaluationResult = await this.judge.evaluate(originalText, generatedText); return { score: evaluationResult.similarityScore, info: evaluationResult, }; } } // --- ワークフローの定義 --- const clonePromptGeneratorWorkflow = new Workflow({ name: \u0026#34;clone-prompt-generator-workflow-with-eval\u0026#34;, // ワークフロー名 triggerSchema: z.object({ originalText: z.string().describe(\u0026#34;The original text written by the user to be cloned.\u0026#34;), }), }); // --- ステップ1: なりきり指示プロンプトの生成 --- const generateClonePromptStep = new Step({ id: \u0026#34;generate-clone-prompt\u0026#34;, execute: async ({ context }) =\u0026gt; { const promptCreatorAgent = new Agent({ name: \u0026#39;Prompt Creator Agent\u0026#39;, instructions: ` # 指示: 最高の「なりきり文章生成プロンプト」を作成してください あなたは、プロンプトエンジニアAIです。あなたの任務は、与えられた**【例文】**を分析し、その書き手の**特徴（人格、文体、癖）**を正確に捉え、その書き手になりきって**人間らしく自然な文章**を生成させるための**「汎用的な指示プロンプト」**を作成することです。 (中略... プロンプトの条件や思考プロセスは変更なし) **さあ、上記すべてを踏まえ、最高の「なりきり文章生成プロンプト」を作成してください。** ${feedbackForPromptCreator} `, model: llm, }); const originalText = context.triggerData.originalText; console.log(\u0026#34;[generate-clone-prompt] プロンプト生成を開始します。\u0026#34;); const result = await promptCreatorAgent.generate(` 【例文】: ${originalText} `); console.log(\u0026#34;[generate-clone-prompt] プロンプト生成が完了しました。\u0026#34;); return `${result.text}`; }, }); // --- 最終ステップ: 成功したプロンプトの出力 --- const outputFinalPromptStep = new Step({ id: \u0026#34;output-final-prompt\u0026#34;, execute: async ({ context }) =\u0026gt; { const finalPrompt = context.getStepResult(generateClonePromptStep) as string; console.log(\u0026#34;--------------------------------------------------\u0026#34;); console.log(\u0026#34;ワークフローが完了しました！\u0026#34;); console.log(\u0026#34;成功したなりきり指示プロンプト:\u0026#34;); console.log(\u0026#34;--------------------------------------------------\u0026#34;); console.log(finalPrompt); // 最終的なプロンプトをコンソールに出力 console.log(\u0026#34;--------------------------------------------------\u0026#34;); return finalPrompt; }, }); // --- ワークフローの組み立て --- clonePromptGeneratorWorkflow .step(generateClonePromptStep) .until(async ({ context }) =\u0026gt; { // iteration を受け取る iteration++; console.log(`\\n--- ループ ${iteration} 開始 ---`); // 1. 生成された「なりきり指示プロンプト」を取得 const generatedClonePrompt = context.getStepResult(generateClonePromptStep) as string; const originalText = context.triggerData.originalText; // 2. originalTextのテーマを抽象化 const themeAbstractorAgent = new Agent({ name: \u0026#39;Theme Abstractor Agent\u0026#39;, instructions: ` 与えられた文章の主要なテーマやトピックを分析し、**具体的な固有名詞、製品名、技術名、サービス名などを避け**、より一般的で抽象的な言葉で表現してください。 出力は、その抽象化されたテーマの説明文のみとし、他の解説や前置きは含めないでください。 例: (省略...) `, model: llm, }); console.log(`[ループ ${iteration}] originalTextからテーマを抽象化中...`); const abstractionResult = await themeAbstractorAgent.generate(` 以下の文章のテーマを抽象化してください:\\n---\\n${originalText}\\n--- `); const abstractedTheme = abstractionResult.text.trim(); console.log(`[ループ ${iteration}] 抽象化されたテーマ: ${abstractedTheme}`); // 3. 抽象化されたテーマで、なりきり文章を生成 const textGeneratorAgent = new Agent({ name: \u0026#39;Text Generator Agent\u0026#39;, instructions: generatedClonePrompt, model: llm, }); console.log(`[ループ ${iteration}] 抽象化されたテーマで文章を生成中...`); const generatedTextResult = await textGeneratorAgent.generate( `「${abstractedTheme}」について、初心者にも分かりやすく解説する文章を作成してください。` ); const generatedText = generatedTextResult.text; // 4. 類似度を評価 console.log(`[ループ ${iteration}] 生成された文章とお手本の文章の類似度を評価中...`); const authorshipMetric = new AuthorshipSimilarityMetric(llm); // 評価メトリクスを使用 const metricResult = await authorshipMetric.measure( originalText, generatedText ); const currentScore = metricResult.score; const reason = metricResult.info.reason; console.log(`[ループ ${iteration}] 評価結果 - スコア: ${currentScore.toFixed(2)}, 理由: ${reason}`); // 5. 評価スコアに基づいてループ継続/終了を判断 const shouldStop = currentScore \u0026gt;= SIMILARITY_THRESHOLD; if (!shouldStop) { feedbackForPromptCreator = ` --- **前回の試行からのフィードバック (ループ ${iteration}):** 生成した「なりきり指示プロンプト」を使って「${abstractedTheme}」について書かせた結果、お手本の文章との類似度が目標に達しませんでした (スコア: ${currentScore.toFixed(2)})。 評価AIは以下の点を指摘しています。これを参考にプロンプトを改善してください。 **失敗したプロンプト:** \\`\\`\\` ${generatedClonePrompt} \\`\\`\\` **評価AIによる指摘:** \\`\\`\\` ${reason} \\`\\`\\` --- `; console.log(`[ループ ${iteration}] スコアが閾値未満のため、フィードバックを作成し再試行します。`); } else { console.log(`[ループ ${iteration}] スコアが閾値 (${SIMILARITY_THRESHOLD}) 以上のため、ループを終了します。`); feedbackForPromptCreator = \u0026#34;\u0026#34;; // 成功したらフィードバックをクリア } console.log(`--- ループ ${iteration} 終了 ---`); return shouldStop; // trueならループ終了、falseなら継続 }, generateClonePromptStep) // ループで回すステップを指定 .then(outputFinalPromptStep) // ループ終了後に実行するステップを指定 .commit(); // ワークフロー定義を確定 export { clonePromptGeneratorWorkflow }; 完成！「なりきり指示プロンプト」とその活用法 最終的な出力\nワークフローが無事に閾値以上のスコアを達成して終了すると、ターミナルのコンソールに、最終的に完成した「なりきり指示プロンプト」が出力されます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -------------------------------------------------- ワークフローが完了しました！ 最終的な類似度スコア: 0.75 (例) 成功したなりきり指示プロンプト: -------------------------------------------------- # 指示プロンプト あなたは、以下に示す特徴を持つ人物になりきって、【記事の内容】から人間らしく自然な文章を生成するAIです。 ## なりきる人物の特徴: ### 人格: * 基本姿勢: 丁寧で親しみやすい。効率的に情報を伝えようと努める。 * 話し方: 柔らかい物腰。「〜な感じです」のような表現も使うが、手順説明はテキパキ。 * 思考: 論理的だが柔軟。実践的。 ... (以下、AIが生成したプロンプトが続く) ... -------------------------------------------------- この出力されたプロンプトをコピーして、今後の文章生成（例えばChatGPTやClaudeなど他のツールで使う場合も）に活用すれば、あなたの文体を模倣した下書きをAIに作ってもらうことができるはずです！\nまとめ 今回はmastraのループ機能と評価機能を使って、AIに自分の文章スタイルを学習させ、それになりきるためのプロンプト自体を自動生成・改善させるワークフローを作ってみました。\nAIにAIの使い方を考えさせるという、少しメタ的なアプローチでしたが、うまくいけば文章作成の効率化に繋がりそうですよね。特に、ブログ記事やレポートなど、ある程度自分のスタイルで書きたいけど、タイピングが大変…と感じている方には試してみる価値があるかもしれません。\nmastra、なかなか奥が深くて面白いライブラリです！皆さんもぜひ、色々なワークフロー作りに挑戦してみてくださいね。\n","date":"2025-04-03T21:00:34+09:00","image":"https://takoyakisoft.com/p/build-llm-workflow-with-mastra/build-llm-workflow-with-mastra_hu_cd3ccd21a5d0f00f.webp","permalink":"https://takoyakisoft.com/p/build-llm-workflow-with-mastra/","title":"mastraでLLMワークフロー自由自在！Grok-2とthinkツール、文章クローンプロンプト生成まで"},{"content":"こんにちは！\n今回は、現在（2025年3月30日時点）無料で利用できる、非常に高性能なAIモデルを使って、簡単なWebゲーム開発を試してみたお話です。\nなんと、Googleの「Gemini 2.5 Pro」の実験的モデル（gemini-2.5-pro-exp-03-25）が、ai.dev というサイトで無料で使えるんです！ これが現時点で最高の性能（SOTA）と言われているモデルの一つらしく、すごいですよね！\nさらに、ByteDance社の「Trae」というエディターにある「Builder」機能（ベータ版）も試してみました。こちらでは、まるでClaudeのようなAIエージェントが利用できて、しかもモデルとして「Claude 3.7 Sonnet」を選択できるんです。これも無料で使えます。\nただし、どちらも無料プランなので、おそらく入力したデータはサービス改善などに利用される可能性があると思います。なので、機密情報を含むような開発には向きませんが、公開するようなプログラムや、個人的な実験にはぴったりかもしれませんね！\nThree.jsでゲームを作ってもらう さて、今回はこれらの強力なAI、特に「Gemini 2.5 Pro」に協力してもらって、JavaScriptの3DライブラリであるThree.jsを使ったゲームを、1つのHTMLファイルだけで作ってもらうことに挑戦しました。\nただ生成するだけでなく、ゲームとして面白くなるように、「ジューシーさ（Juiciness）」という概念をAIに伝えて、何度か修正をお願いしてみました。「ジューシーさ」というのは、操作したときの気持ちよさや、エフェクトの派手さみたいな、ゲームプレイの感触を良くする要素のことですね。\n出来上がったゲーム そして、出来上がったのがこちらのゲームです！\n操作方法:\nマウスカーソルを動かすとカメラの視点が移動します。 マウスクリックで弾を発射します。 ESCキーで操作のフォーカスを終了できます。 結構シンプルな内容ですが、マウス操作に対する反応やエフェクトに「ジューシーさ」を少し感じられるかもしれません。\n生成時間と注意点 このゲーム、実は1つのindex.htmlファイルだけで完結していて、コードの行数は約1500行になりました。\nこれをGemini 2.5 Pro（gemini-2.5-pro-exp-03-25モデル）で生成したところ、出力に約180秒かかっていました。結構時間がかかりますね。\nこの経験からすると、現状では、AIに1ファイルで完結するコードを生成してもらう場合、1000行くらいを目安にするのが、現実的な時間で作業を進める上では良さそうかな、という感じです。\nもちろん、これはモデルの性能や混雑状況によって変わる可能性はありますが、一つの目安として参考にしてみてください。\nまとめ 今回は、無料で使える最新のAIモデル「Gemini 2.5 Pro」や「Trae Builder (Claude 3.7 Sonnet)」を使って、Three.jsのゲームを生成する試みについてご紹介しました。\n無料でこれだけの性能のAIが使えるのは本当に驚きですし、アイデア次第で色々なものが作れそうですね！特に、公開前提のプロジェクトや学習目的には、とても有用なツールだと思います。\nコード生成の時間など、まだ少しクセはあるかもしれませんが、試してみる価値は十分にあると感じました。\nここまで読んでくださり、ありがとうございました！皆さんもぜひ試してみてください。\n","date":"2025-03-30T23:43:05+09:00","image":"https://takoyakisoft.com/p/free-ai-models-create-threejs-game/free-ai-models-create-threejs-game_hu_6af50b4fb5b6c13f.webp","permalink":"https://takoyakisoft.com/p/free-ai-models-create-threejs-game/","title":"最新無料AIモデル Gemini 2.5 Pro と Trae Builder を使ってThree.jsゲーム開発に挑戦！"},{"content":"はじめに こんにちは！\nPygameで作った自作ゲーム、せっかくならWebで公開して、たくさんの人に遊んでもらいたいですよね。私もそう思います！\nこの記事では、Pythonのゲームライブラリ Pygame で作ったゲームを、Webブラウザで誰でも簡単にプレイできるように公開する方法を、一緒に見ていきたいと思います。できるだけ分かりやすく解説してみますね。\nこの記事で分かること:\npygbag というツールで、Pygameゲームを WebAssembly (WASM) を使ってWeb向けに変換（ビルド）する方法。これが結構便利なんです。 Hugo という静的サイトジェネレーターで作ったブログに、変換したゲームを埋め込んで公開する手順。 ゲームを記事に簡単に埋め込むための、Hugoショートコードの作り方。これも作っておくと後が楽ちんですよ。 この手順なら、特別なサーバー設定もいらず、ブラウザだけで遊んでもらえるようになります。嬉しいですね！あなたの作ったゲームを世界中の人に遊んでもらえるようになるかもしれません！\n出来上がったゲーム それで、実際にこの方法で作ってみたのが、こちらのゲームです！ （ただ眺めるゲームです。）\nPygameゲームをWeb向けにビルドする: pygbag という便利なツールを使ってみます pygbag は、PygameゲームをWebブラウザで直接動かせるようにパッケージ化してくれる、本当に便利なツールだと思います。これを使って、まずはゲームをWeb用に変換してみましょう。\n1. まず、uv でプロジェクトの準備をしましょう ここでは uv という、最近注目されているPythonのパッケージ管理ツールを使ってみます。もし uv がなければ、まずインストールしましょう。（もし pip など他のツールを使っている方は、そちらで大丈夫ですよ）\n※ uv のインストール (まだの場合、このコマンドはWindows用ですね)\n1 powershell -ExecutionPolicy ByPass -c \u0026#34;irm https://astral.sh/uv/install.ps1 | iex\u0026#34; 次に、uv init でゲームプロジェクト用のフォルダ作成と初期化をします。 the-labyrinth-of-gaze は、今回例として使うゲームの名前なので、ここはご自身のプロジェクト名に置き換えてくださいね。\n※ uv でプロジェクトを初期化\n1 2 uv init the-labyrinth-of-gaze cd the-labyrinth-of-gaze 次に、必要なライブラリ pygbag と pygame をインストールします。uv だとこんな感じです。\n1 uv add pygbag pygame （もし uv を使わない場合は、pip install pygbag pygame のような感じで、お手元の環境に合わせてインストールしてくださいね）\n2. いよいよゲームをビルドします uv init で自動で作られた main.py か、ご自身のゲームのメインとなるスクリプトファイルに、Pygameのゲームコードを書きます。\nこの記事の例で使ったゲームコードは、最後に添付します。\n準備ができたら、以下のコマンドでゲームをWeb向けにビルドを実行します。 main.py のところは、あなたのゲームのメインスクリプトファイル名に変えてください。\n1 uv run pygbag --build .\\main.py このコマンドが成功すると、今いるフォルダ（カレントディレクトリ）に build/web というフォルダができて、その中にWebブラウザでゲームを動かすためのファイル (index.html や the-labyrinth-of-gaze.apk など) が入っているはずです。\nビルドされたファイルの例はこんな感じですね: /game/the-labyrinth-of-gaze/build/web/index.html\nHugoブログにゲームを埋め込む 次に、ビルドしたゲームをHugoブログに組み込んでいきましょう。 ここでは hugo-theme-stack というテーマを例にしますが、基本的な考え方は他のHugoテーマでも同じだと思います。\n1. ゲームファイルを置く場所についてです Hugoには static という便利なフォルダがあって、ここに入れたファイルやフォルダは、サイトを作るときにそのままルート（Webサイトの一番上の階層）にコピーしてくれるんです。ここに、さっき pygbag で作ったゲームファイルを置いていきます。\n配置手順 (例: ゲーム名 the-labyrinth-of-gaze の場合):\nHugoプロジェクトのルートにある static フォルダの中に game というフォルダを作ります（もしなければ作ってくださいね）。 static/game/ の中に、さらにゲーム用のフォルダを作ります (例: the-labyrinth-of-gaze)。 先ほど pygbag で生成された build/web フォルダの中身を、今作った static/game/the-labyrinth-of-gaze/ フォルダの中にコピーします。 注意: ここ、大事なポイントです！ build/web フォルダごとコピーするのではなく、その中のファイル群 (index.html, the-labyrinth-of-gaze.apk など) をコピーしてくださいね。 配置後のフォルダ構成は、こんな感じになると思います。\n1 2 3 4 5 6 7 8 9 (あなたのHugoプロジェクトフォルダ)/ └── static/ └── game/ └── the-labyrinth-of-gaze/ \u0026lt;-- このフォルダにビルド結果をコピー └── build/ └── web/ ├── index.html ├── the-labyrinth-of-gaze.apk └── (その他必要なファイル) ... ポイント: こうしておくと、後でWebサイトから /game/the-labyrinth-of-gaze/build/web/index.html みたいなURLでゲームの index.html にアクセスできるようになります。\n2. 毎回 \u0026lt;iframe\u0026gt; を書くのは大変なので、Hugoのショートコードを作りましょう Hugoには ショートコード という便利な機能があるので、これを使って楽にゲームを埋め込めるようにしてみます。これを作っておくと、後々すごく楽ですよ。\nHugoプロジェクトの layouts/shortcodes/ フォルダの中に game-iframe.html という名前で新しいファイルを作って、以下のコードを貼り付けてみてください。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 {{/* layouts/shortcodes/game-iframe.html */}} {{/* ゲームのURLを \u0026#39;src\u0026#39; で受け取る */}} {{ $src := .Get \u0026#34;src\u0026#34; }} {{/* アスペクト比を \u0026#39;aspect-ratio\u0026#39; で受け取る (指定なければ 75% = 4:3) */}} {{ $aspectRatio := .Get \u0026#34;aspect-ratio\u0026#34; | default \u0026#34;75%\u0026#34; }} {{/* レスポンシブ対応のiframe埋め込みスタイル */}} \u0026lt;div style=\u0026#34;position: relative; padding-bottom: {{ $aspectRatio }}; height: 0; overflow: hidden; max-width: 100%; height: auto;\u0026#34;\u0026gt; \u0026lt;iframe src=\u0026#34;{{ $src }}\u0026#34; style=\u0026#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 1px solid #ccc;\u0026#34; title=\u0026#34;Embedded Game\u0026#34; sandbox=\u0026#34;allow-scripts allow-same-origin allow-pointer-lock allow-fullscreen\u0026#34; loading=\u0026#34;lazy\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; このショートコードが何をしているかというと…:\nsrc パラメータで、埋め込みたいゲームのURLを受け取ります。 aspect-ratio パラメータで、ゲーム画面の見た目の比率（アスペクト比）を指定できるようにします (例: 75% は 4:3、56.25% は 16:9)。もし指定しなかったら、デフォルトで 75% (4:3っぽい感じ) になるようにしています。 指定されたURLのコンテンツを \u0026lt;iframe\u0026gt; で埋め込むんですが、 CSSを使って、画面サイズが変わっても形が崩れないように（レスポンシブ対応ってやつですね）調整しています。 sandbox 属性で、iframeの中身がちょっと安全に動くように制限をかけています。 loading=\u0026quot;lazy\u0026quot; を付けて、iframeが表示される近くに来るまで読み込みを遅らせることで、ページの表示が少し速くなるように、ちょっとした工夫をしています。 3. さあ、準備ができました！記事で使ってみましょう これで準備完了です！ゲームを紹介したい記事のMarkdownファイルを開いて、さっき作ったショートコードを使ってみましょう。\n例えば、content/posts/my-pygame-game.md のような記事ファイルを作って、本文中にこんなふうに書きます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- title: \u0026#34;自作Pygameゲーム「眺める迷路」を公開！\u0026#34; # 記事のタイトル date: 2025-03-28T00:00:00+09:00 description: \u0026#34;Pygameとpygbagで作った迷路ゲームを公開しました。ブラウザで気軽に遊べます！\u0026#34; # 記事の説明 slug: the-labyrinth-of-gaze-game # 記事のスラッグ（URLの一部） image: the-labyrinth-of-gaze.webp # アイキャッチ画像 categories: [\u0026#34;ゲーム\u0026#34;] # カテゴリ tags: [\u0026#34;Pygame\u0026#34;, \u0026#34;自作ゲーム\u0026#34;, \u0026#34;パズル\u0026#34;] # タグ draft: false --- Pygameで作った「眺める迷路」ゲームをWebで公開してみました！ `pygbag` を使うと、こんな風にブログに埋め込めるんですね。便利！ ぜひブラウザで気軽に遊んでみてください。 {{\u0026lt; game-iframe src=\u0026#34;/game/the-labyrinth-of-gaze/build/web/index.html\u0026#34; aspect-ratio=\u0026#34;75%\u0026#34; \u0026gt;}} 操作方法: * （ここにゲームの操作方法などを具体的に書いてくださいね） * 例: 矢印キーで移動、スペースキーでジャンプ など ゲームの説明: （ここにゲームのルールや目的、見どころなどを書くと良いと思います） 楽しんでいただけたら嬉しいです！ ここでのポイントは…:\n{{\u0026lt; ... \u0026gt;}} の中に、先ほど作成したショートコード名 game-iframe を書きます。 src パラメータには、さっき static フォルダに置いたゲームの index.html への Webサイト上での絶対パス (/ から始まるパス) を指定します。 例: static/game/the-labyrinth-of-gaze/build/web/index.html に置いた場合は、/game/the-labyrinth-of-gaze/build/web/index.html と書きます。 重要: ここ、間違えやすいので注意です！ あなたのゲームの配置場所に合わせて、このパスを正しく書いてくださいね。 aspect-ratio は、あなたのゲーム画面に合わせて調整すると、見た目がいい感じになると思います (例: 16:9 なら 56.25% とか)。 ショートコードの下には、もちろん操作方法とかゲームの説明とか、自由に書けますよ。 ここまでできたら、あとは hugo コマンドでサイトをビルドして公開すれば、記事の中にゲームが埋め込まれて表示されるはずです！\nまとめ 今回は、pygbag という便利なツールを使って Pygame ゲームを WebAssembly (WASM) に変換し、それを Hugo ブログの static フォルダに配置して、さらに iframe 埋め込み用の Hugo ショートコード を作って記事内に簡単に表示する、という手順を見てきました。\nこの方法のいいところは、個人的にはこんな点かなと思います:\n特別なサーバー設定がいらない！ 静的なファイルだけでゲームを公開できるのは手軽でいいですよね。 ブログ記事の中にインタラクティブなゲームを簡単に追加できるって、なんだかワクワクしませんか？ あなたの作った Pygame ゲームをより多くの人に遊んでもらえるチャンスが広がります！ 見てくれる人も、ブラウザのプラグインとか何もなしで、すぐに遊べるのが嬉しいですね。 もしあなたがPygameでゲームを作っていて、「Webで公開してみたいな」と思っていたら、ぜひこの手順を参考にして、チャレンジしてみてはいかがでしょうか。\n最後まで読んでくださって、ありがとうございました！\nソースコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 # Pygameを使ったA*アルゴリズムによる迷路探索アニメーション (自動進行＆エフェクト追加・修正版) import pygame import random import heapq import math import time # dt計算のために追加 (なくてもclock.tickでOK) # --- 定数 --- # グリッド設定 GRID_WIDTH = 31 GRID_HEIGHT = 25 CELL_SIZE = 15 MARGIN = 1 # ウィンドウサイズ WINDOW_WIDTH = GRID_WIDTH * (CELL_SIZE + MARGIN) + MARGIN WINDOW_HEIGHT = GRID_HEIGHT * (CELL_SIZE + MARGIN) + MARGIN # 色 (RGB) - モダンな配色に更新 WHITE = (245, 245, 245) BLACK = (20, 20, 30) GREY = (180, 180, 180) GREEN = (76, 187, 23) RED = (235, 64, 52) BLUE = (66, 135, 245) YELLOW = (250, 204, 21) CYAN = (28, 186, 210) ORANGE = (255, 126, 28) LIGHT_ORANGE = (255, 183, 77) # 点滅用 PATH_HIGHLIGHT = (130, 210, 240) # ライトブルー (経路表示アニメ用) PATH_HIGHLIGHT_PULSE = (180, 230, 250) # パルスエフェクト用 GOAL_FLASH = (255, 255, 255) # ゴール到達時エフェクト用 HOVER_COLOR = (220, 220, 220) # ホバーエフェクト用 PURPLE = (180, 120, 240) # 新しい色 PINK = (255, 105, 180) # 新しい色 # アニメーション速度 (Frame Per Second) FPS = 60 # 自動リセットまでの待機時間 (秒) RESET_DELAY_SECONDS = 2.0 # 経路ハイライトアニメーションの速度 (1フレームあたりに進むマス数、小さいほど遅い) PATH_HIGHLIGHT_SPEED = 0.3 # --- ヘルパー関数 (変更なし) --- def heuristic(a, b): (r1, c1) = a (r2, c2) = b return abs(r1 - r2) + abs(c1 - c2) def get_valid_neighbors(node, grid): neighbors = [] row, col = node rows = len(grid) cols = len(grid[0]) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] for dr, dc in directions: nr, nc = row + dr, col + dc if 0 \u0026lt;= nr \u0026lt; rows and 0 \u0026lt;= nc \u0026lt; cols and grid[nr][nc] == 0: neighbors.append((nr, nc)) return neighbors def reconstruct_path(came_from, current): path = [] while current in came_from: path.append(current) current = came_from[current] path.reverse() return path def generate_maze(width, height): grid = [[1 for _ in range(width)] for _ in range(height)] start_r, start_c = random.randrange(1, height, 2), random.randrange(1, width, 2) grid[start_r][start_c] = 0 stack = [(start_r, start_c)] visited = {(start_r, start_c)} while stack: cr, cc = stack[-1] neighbors = [] for dr, dc in [(0, 2), (0, -2), (2, 0), (-2, 0)]: nr, nc = cr + dr, cc + dc if 0 \u0026lt; nr \u0026lt; height - 1 and 0 \u0026lt; nc \u0026lt; width - 1 and (nr, nc) not in visited: neighbors.append((nr, nc)) if neighbors: nr, nc = random.choice(neighbors) grid[(cr + nr) // 2][(cc + nc) // 2] = 0 grid[nr][nc] = 0 visited.add((nr, nc)) stack.append((nr, nc)) else: stack.pop() passages = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0] if len(passages) \u0026lt; 2: start_node = (1, 1) if height \u0026gt; 1 and width \u0026gt; 1 else (0, 0) end_node = (height - 2, width - 2) if height \u0026gt; 2 and width \u0026gt; 2 else start_node if grid[start_node[0]][start_node[1]] == 1: grid[start_node[0]][start_node[1]] = 0 if grid[end_node[0]][end_node[1]] == 1: grid[end_node[0]][end_node[1]] = 0 else: start_node = random.choice(passages) end_node = random.choice(passages) while end_node == start_node: end_node = random.choice(passages) return grid, start_node, end_node # パーティクルクラス定義 - より多様なエフェクト対応に改良 class Particle: def __init__(self, x, y, color, particle_type=\u0026#34;normal\u0026#34;): self.x = x self.y = y self.base_color = color # 元の色を保持 self.color = color self.particle_type = particle_type self.size = ( random.randint(2, 6) if particle_type == \u0026#34;normal\u0026#34; else random.randint(3, 8) ) self.speed = ( random.uniform(1, 5) * 50 # スピード調整 (dtベース) if particle_type == \u0026#34;normal\u0026#34; else random.uniform(0.5, 3) * 50 # スピード調整 (dtベース) ) self.angle = random.uniform(0, math.pi * 2) self.lifespan = ( random.uniform(0.5, 1.5) if particle_type == \u0026#34;normal\u0026#34; else random.uniform(1.0, 2.5) ) self.age = 0 self.pulse_rate = random.uniform(3.0, 6.0) # パルスエフェクト用 self.original_size = self.size # サイズ変動用 self.fade_in_duration = 0.3 # フェードイン時間 self.fade_out_start_ratio = 0.7 # 寿命の何割からフェードアウト開始か # 星型パーティクル用の頂点数 self.vertices = random.randint(4, 6) if particle_type == \u0026#34;star\u0026#34; else 0 # 軌跡パーティクル用 self.trail = [] self.trail_length = 5 if particle_type == \u0026#34;trail\u0026#34; else 0 # 波紋エフェクト用 if particle_type == \u0026#34;ripple\u0026#34;: self.size = 1 self.max_size = random.randint(15, 25) self.expand_speed = random.uniform(0.8, 1.2) * 30 # スピード調整 (dtベース) self.lifespan = random.uniform(1.0, 1.5) self.speed = 0 # 波紋は移動しない def update(self, dt): self.x += math.cos(self.angle) * self.speed * dt self.y += math.sin(self.angle) * self.speed * dt self.age += dt # パーティクルタイプに応じた更新処理 size_decay_rate = self.original_size / (self.lifespan * (1.0 - self.fade_out_start_ratio)) if self.lifespan \u0026gt; 0 else 1 if self.particle_type == \u0026#34;normal\u0026#34;: if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: self.size = max(0, self.size - size_decay_rate * dt) elif self.particle_type == \u0026#34;pulse\u0026#34;: pulse = math.sin(self.age * self.pulse_rate) * 0.5 + 0.5 current_size_factor = 1.0 if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: current_size_factor = max(0, 1 - (self.age - self.lifespan * self.fade_out_start_ratio) / (self.lifespan * (1.0 - self.fade_out_start_ratio))) self.size = self.original_size * (0.5 + pulse * 0.5) * current_size_factor elif self.particle_type == \u0026#34;fade_in\u0026#34;: if self.age \u0026lt; self.fade_in_duration: self.size = self.original_size * (self.age / self.fade_in_duration) elif self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: fade_out_duration = self.lifespan * (1.0 - self.fade_out_start_ratio) self.size = max(0, self.original_size * (1 - (self.age - self.lifespan * self.fade_out_start_ratio) / fade_out_duration)) else: self.size = self.original_size # フェードイン後、フェードアウト前は最大サイズ elif self.particle_type == \u0026#34;trail\u0026#34;: self.trail.append((self.x, self.y)) if len(self.trail) \u0026gt; self.trail_length: self.trail.pop(0) if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: self.size = max(0, self.size - size_decay_rate * dt * 0.5) # Trailは少しゆっくり消える elif self.particle_type == \u0026#34;ripple\u0026#34;: self.size = min(self.size + self.expand_speed * dt, self.max_size) elif self.particle_type == \u0026#34;star\u0026#34;: if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: self.size = max(0, self.size - size_decay_rate * dt) else: # default or rainbow etc. if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: self.size = max(0, self.size - size_decay_rate * dt) # 色の変化（時間経過で色相が変化 - rainbowタイプ） if self.particle_type == \u0026#34;rainbow\u0026#34;: hue_shift = (self.age * 100) % 360 # HSV -\u0026gt; RGB変換 (簡易版) r_val, g_val, b_val = 0, 0, 0 i = int(hue_shift / 60) % 6 f = hue_shift / 60 - i v = 1.0 # 明度 s = 1.0 # 彩度 p = v * (1 - s) q = v * (1 - f * s) t = v * (1 - (1 - f) * s) if i == 0: r_val, g_val, b_val = v, t, p elif i == 1: r_val, g_val, b_val = q, v, p elif i == 2: r_val, g_val, b_val = p, v, t elif i == 3: r_val, g_val, b_val = p, q, v elif i == 4: r_val, g_val, b_val = t, p, v elif i == 5: r_val, g_val, b_val = v, p, q self.color = (int(r_val*255), int(g_val*255), int(b_val*255)) def draw(self, surface): if self.size \u0026lt;= 0: # サイズが0以下なら描画しない return # フェードイン/アウト効果の透明度計算 alpha = 255 if self.particle_type == \u0026#34;ripple\u0026#34;: # 波紋エフェクトの透明度計算 (徐々に薄くなる) progress = self.age / self.lifespan if self.lifespan \u0026gt; 0 else 1 alpha = max(0, min(255, int(255 * (1 - progress) * 0.8))) # 終盤はより透明に elif self.particle_type == \u0026#34;fade_in\u0026#34;: if self.age \u0026lt; self.fade_in_duration: alpha = int(255 * (self.age / self.fade_in_duration)) elif self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: fade_out_duration = self.lifespan * (1.0 - self.fade_out_start_ratio) if fade_out_duration \u0026gt; 0: alpha = max(0, min(255, int(255 * (1 - (self.age - self.lifespan * self.fade_out_start_ratio) / fade_out_duration)))) else: alpha = 0 # 念のため else: alpha = 255 else: # Normal, Pulse, Star, Trail, Rainbow etc. # 共通のフェードアウト処理 if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: fade_out_duration = self.lifespan * (1.0 - self.fade_out_start_ratio) if fade_out_duration \u0026gt; 0: alpha = max(0, min(255, int(255 * (1 - (self.age - self.lifespan * self.fade_out_start_ratio) / fade_out_duration)))) else: alpha = 0 else: alpha = 255 # 色の検証と設定 try: current_color = self.color if self.particle_type == \u0026#34;rainbow\u0026#34; else self.base_color if isinstance(current_color, tuple) and len(current_color) == 3: r = max(0, min(255, int(current_color[0]))) g = max(0, min(255, int(current_color[1]))) b = max(0, min(255, int(current_color[2]))) final_color = (r, g, b, alpha) else: final_color = (255, 255, 255, alpha) # デフォルト色 # パーティクルタイプに応じた描画 if self.particle_type == \u0026#34;ripple\u0026#34;: # 波紋エフェクト (輪郭を描画) line_width = max(1, int(self.max_size / 15 * (1 - self.age / self.lifespan))) # 徐々に細くなる輪郭 if self.size \u0026gt;= 1: # 最小半径1以上 pygame.draw.circle(surface, final_color, (int(self.x), int(self.y)), int(self.size), width=line_width) elif self.particle_type == \u0026#34;star\u0026#34; and self.vertices \u0026gt; 0: # 星型パーティクル points = [] outer_radius = self.size inner_radius = self.size * 0.4 for i in range(self.vertices * 2): angle = math.pi / self.vertices * i - math.pi / 2 # 頂点が上に来るように調整 radius = outer_radius if i % 2 == 0 else inner_radius x_p = self.x + math.cos(angle) * radius y_p = self.y + math.sin(angle) * radius points.append((x_p, y_p)) if len(points) \u0026gt;= 3: # 少なくとも3点必要 pygame.draw.polygon(surface, final_color, points) elif self.particle_type == \u0026#34;trail\u0026#34; and len(self.trail) \u0026gt; 1: # 軌跡パーティクル for i in range(len(self.trail) - 1): start_pos = self.trail[i] end_pos = self.trail[i + 1] # 軌跡のアルファと太さを調整 trail_alpha = alpha * ((i + 1) / len(self.trail))**2 # 後ろほど薄く trail_width = max(1, int(self.size * ((i + 1) / len(self.trail)))) trail_color_tuple = (final_color[0], final_color[1], final_color[2], int(trail_alpha)) pygame.draw.line(surface, trail_color_tuple, start_pos, end_pos, trail_width) # 先端の円も描画 pygame.draw.circle(surface, final_color, (int(self.x), int(self.y)), int(self.size)) else: # 通常の円形パーティクル (Normal, Pulse, Fade_in, Rainbow) pygame.draw.circle(surface, final_color, (int(self.x), int(self.y)), int(self.size)) except (ValueError, TypeError) as e: # エラーが発生した場合はデフォルト色を使用 print(f\u0026#34;Error drawing particle: {e}, color={self.color}, alpha={alpha}, size={self.size}\u0026#34;) try: safe_color = (255, 255, 255, alpha) if self.size \u0026gt;= 1: pygame.draw.circle(surface, safe_color, (int(self.x), int(self.y)), int(max(1, self.size))) # 最小サイズ1を保証 except Exception as final_e: print(f\u0026#34;Final fallback drawing failed: {final_e}\u0026#34;) # --- Pygame初期化 --- pygame.init() screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT)) pygame.display.set_caption(\u0026#34;A* Maze Solver Animation (Auto-Repeat, ESC: Quit)\u0026#34;) clock = pygame.time.Clock() font = pygame.font.Font(None, 24) # --- 状態変数 --- grid = [] start_node = None end_node = None open_set_heap = [] open_set_map = {} closed_set = set() came_from = {} g_score = {} path = [] current_node = None solving = False maze_generated = False message = \u0026#34;\u0026#34; particles = [] # パーティクル用リスト (ripplesもここに統合) # ripples = [] # 不要になったので削除 node_pulses = [] # ノード探索時のパルスエフェクト用 (現状未使用かも？) # --- 自動リセット用変数 --- reset_timer = 0 # 待機フレームカウンタ RESET_DELAY_FRAMES = int(RESET_DELAY_SECONDS * FPS) # 秒をフレーム数に変換 start_reset_timer_after_highlight = False # ハイライト完了後にタイマーを開始するフラグ # --- 経路ハイライトアニメーション用変数 --- path_highlight_index = 0.0 # floatでゆっくり進める highlighting_path = False # --- ゴール到達エフェクト用 --- goal_reached_flash = False # ゴール到達直後のフレームか # --- メインループ --- running = True frame_count = 0 # 点滅アニメーション用 hover_cell = None # ホバー中のセル while running: # --- デルタタイム計算 --- dt = clock.tick(FPS) / 1000.0 # 秒単位のデルタタイム (0除算を避ける) if dt == 0: dt = 1 / FPS # 最小時間ステップを保証 # --- イベント処理 --- for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if event.type == pygame.KEYDOWN: if event.key == pygame.K_ESCAPE: running = False # マウス座標からホバー中のセルを取得 mouse_pos = pygame.mouse.get_pos() mouse_col = mouse_pos[0] // (CELL_SIZE + MARGIN) mouse_row = mouse_pos[1] // (CELL_SIZE + MARGIN) if 0 \u0026lt;= mouse_row \u0026lt; GRID_HEIGHT and 0 \u0026lt;= mouse_col \u0026lt; GRID_WIDTH: hover_cell = (mouse_row, mouse_col) else: hover_cell = None # --- 状態更新 --- if not maze_generated: # 待機タイマーをリセット reset_timer = 0 start_reset_timer_after_highlight = False highlighting_path = False path_highlight_index = 0.0 goal_reached_flash = False hover_cell = None particles = [] # 既存のパーティクルをクリア message = \u0026#34;Generating new maze...\u0026#34; screen.fill(BLACK) msg_render = font.render(message, True, WHITE) screen.blit(msg_render, (10, WINDOW_HEIGHT // 2 - 10)) pygame.display.flip() grid, start_node, end_node = generate_maze(GRID_WIDTH, GRID_HEIGHT) open_set_heap = [] open_set_map = {} closed_set = set() came_from = {} path = [] current_node = None g_score = { (r, c): float(\u0026#34;inf\u0026#34;) for r in range(GRID_HEIGHT) for c in range(GRID_WIDTH) } if start_node: # start_nodeがNoneでないことを確認 g_score[start_node] = 0 h_start = heuristic(start_node, end_node) if end_node else 0 f_start = g_score[start_node] + h_start heapq.heappush(open_set_heap, (f_start, h_start, start_node)) open_set_map[start_node] = (f_start, h_start) maze_generated = True solving = True if start_node and end_node else False # 開始/終了ノードがない場合は解かない message = \u0026#34;Solving...\u0026#34; if solving else \u0026#34;Maze generated (No start/end?)\u0026#34; # --- A*アルゴリズムのステップ実行 --- if solving and open_set_heap: current_f, current_h, current_node_popped = heapq.heappop(open_set_heap) # open_set_map から削除されたか、より良い経路が後で見つかった場合はスキップ if current_node_popped not in open_set_map or open_set_map[current_node_popped] \u0026gt; (current_f, current_h): pass # 無視して次のループへ else: # 処理するので open_set_map から削除 (再追加される可能性はある) # heapqからpopされた時点で処理対象とするため、delは不要かも。重複チェックは上記ifで行う。 # del open_set_map[current_node_popped] # ここでの削除は不要かも current_node = current_node_popped if current_node == end_node: path = reconstruct_path(came_from, current_node) solving = False message = \u0026#34;Goal Reached! Highlighting path...\u0026#34; current_node = None highlighting_path = True path_highlight_index = 0.0 goal_reached_flash = True # エフェクト生成フラグON start_reset_timer_after_highlight = True else: closed_set.add(current_node) # open_set_map からは確実に削除（closedに入ったので） if current_node in open_set_map: del open_set_map[current_node] # 探索中のノードに波紋エフェクトを追加 node_x = (current_node[1] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 node_y = (current_node[0] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 # 波紋エフェクトを生成 (Particleクラスを使用) particles.append(Particle(node_x, node_y, YELLOW, \u0026#34;ripple\u0026#34;)) # 色をYELLOWに変更 # 小さなパーティクルを少量生成 (探索時に) if random.random() \u0026lt; 0.1: # 確率を少し下げる for _ in range(1): # 数を減らす color = random.choice([YELLOW, ORANGE]) # 色を探索色に合わせる particles.append(Particle(node_x, node_y, color, \u0026#34;fade_in\u0026#34;)) for neighbor in get_valid_neighbors(current_node, grid): if neighbor in closed_set: continue tentative_g_score = g_score[current_node] + 1 # この経路が既存の経路より良くない、またはopen setに既により良い経路がある場合は無視 # 注意: open_set_mapには (f, h) が格納されている neighbor_in_open = open_set_map.get(neighbor) if neighbor_in_open and tentative_g_score \u0026gt;= g_score.get(neighbor, float(\u0026#39;inf\u0026#39;)): continue # より良い経路が見つかった場合、または初めて訪れる場合 came_from[neighbor] = current_node g_score[neighbor] = tentative_g_score h_neighbor = heuristic(neighbor, end_node) f_neighbor = tentative_g_score + h_neighbor # open_setになければ追加、あれば更新(heapqは更新を直接サポートしないので、新しい要素を追加) heapq.heappush(open_set_heap, (f_neighbor, h_neighbor, neighbor)) open_set_map[neighbor] = (f_neighbor, h_neighbor) # f, h を保存 elif solving and not open_set_heap: solving = False message = f\u0026#34;No path found! Resetting in {RESET_DELAY_SECONDS:.1f}s...\u0026#34; current_node = None reset_timer = RESET_DELAY_FRAMES # 探索失敗時はすぐにタイマー開始 # --- 経路ハイライト処理 --- if highlighting_path and path: if path_highlight_index \u0026lt; len(path): path_highlight_index += PATH_HIGHLIGHT_SPEED * FPS * dt # dtを使って速度を調整 # 完了した瞬間の処理 if path_highlight_index \u0026gt;= len(path): path_highlight_index = len(path) if start_reset_timer_after_highlight: reset_timer = RESET_DELAY_FRAMES message = f\u0026#34;Path complete! Resetting in {RESET_DELAY_SECONDS:.1f}s...\u0026#34; start_reset_timer_after_highlight = False # --- 自動リセットタイマー処理 --- if reset_timer \u0026gt; 0: reset_timer -= 1 # フレームベースでカウントダウン remaining_time = reset_timer / FPS # 秒に変換して表示 if not solving and not path: message = f\u0026#34;No path found! Resetting in {remaining_time:.1f}s...\u0026#34; elif not solving and path and path_highlight_index \u0026gt;= len(path): message = f\u0026#34;Path complete! Resetting in {remaining_time:.1f}s...\u0026#34; if reset_timer \u0026lt;= 0: maze_generated = False # --- 描画処理 --- # グラデーション背景 for y in range(WINDOW_HEIGHT): time_factor = math.sin(frame_count * 0.005) * 0.2 r_base = 30 + int(10 * time_factor) g_base = 40 + int(15 * time_factor) b_base = 60 + int(20 * time_factor) gradient_factor = math.sin(math.pi * y / WINDOW_HEIGHT) r = int(r_base + (50 - r_base) * gradient_factor) # 少し暗めに調整 g = int(g_base + (70 - g_base) * gradient_factor) # 少し暗めに調整 b = int(b_base + (90 - b_base) * gradient_factor) # 少し暗めに調整 pygame.draw.line(screen, (max(0,r), max(0,g), max(0,b)), (0, y), (WINDOW_WIDTH, y)) # セルの質感向上（影と光沢）- この部分は元のままでも良い shadow_surface = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT), pygame.SRCALPHA) for row in range(GRID_HEIGHT): for col in range(GRID_WIDTH): rect = pygame.Rect( (MARGIN + CELL_SIZE) * col + MARGIN, (MARGIN + CELL_SIZE) * row + MARGIN, CELL_SIZE, CELL_SIZE, ) if grid[row][col] == 0: # 通路 pygame.draw.rect(shadow_surface, (0, 0, 0, 30), rect.inflate(1, 1), border_radius=3) # 少し薄い影 light_rect = rect.inflate(-3, -3).move(-1, -1) pygame.draw.rect(shadow_surface, (255, 255, 255, 50), light_rect, border_radius=2) # 光沢も少し控えめ else: # 壁 pygame.draw.rect(shadow_surface, (0, 0, 0, 20), rect.inflate(1, 1), border_radius=2) pygame.draw.rect(shadow_surface, (0, 0, 0, 30), rect.inflate(-2, -2), border_radius=1, width=1) # 内側の影 screen.blit(shadow_surface, (0, 0)) # ゴール到達時のパーティクル生成 if goal_reached_flash: goal_x = (end_node[1] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 goal_y = (end_node[0] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 # 多様なパーティクルタイプを生成 for _ in range(40): # 通常パーティクル増量 color = random.choice([RED, YELLOW, ORANGE, BLUE, GREEN, PURPLE, PINK, WHITE]) particles.append(Particle(goal_x, goal_y, color, \u0026#34;normal\u0026#34;)) for _ in range(15): # 星型パーティクル増量 color = random.choice([YELLOW, WHITE, ORANGE, CYAN]) particles.append(Particle(goal_x, goal_y, color, \u0026#34;star\u0026#34;)) for _ in range(10): # パルスエフェクト color = random.choice([CYAN, PURPLE, PINK, BLUE]) particles.append(Particle(goal_x, goal_y, color, \u0026#34;pulse\u0026#34;)) for _ in range(8): # 軌跡パーティクル color = random.choice([BLUE, CYAN, WHITE, GREEN]) particles.append(Particle(goal_x, goal_y, color, \u0026#34;trail\u0026#34;)) for _ in range(10): # 虹色パーティクル particles.append(Particle(goal_x, goal_y, WHITE, \u0026#34;rainbow\u0026#34;)) # 初期色は白でOK for _ in range(6): # 波紋エフェクトもParticleとして生成 color = random.choice([WHITE, CYAN, BLUE, YELLOW]) # 波紋の色 particles.append(Particle(goal_x, goal_y, color, \u0026#34;ripple\u0026#34;)) # rippleタイプで生成 goal_reached_flash = False # ★★★ パーティクル生成直後にフラグをリセット ★★★ # セル描画ループ for row in range(GRID_HEIGHT): for col in range(GRID_WIDTH): color = WHITE if grid[row][col] == 1: color = BLACK node = (row, col) is_path_node = False # 経路ハイライト対象かどうかのフラグ # --- セルの状態に応じた色設定 --- if node in closed_set: # closedリストの色 (探索済み) - 少し暗めのCYAN color = (20, 140, 160) # open_set_mapにあるノード (探索候補) - 少し暗めのYELLOW # heapqに同じノードが複数あっても、open_set_mapには最新の(f,h)が入っているはず if node in open_set_map: color = (200, 160, 10) # 少し暗めのYELLOW # --- 経路ハイライト --- if highlighting_path and path: current_path_segment_index = int(path_highlight_index) if node in path[:current_path_segment_index]: is_path_node = True pulse_factor = math.sin(frame_count * 0.15 + path.index(node) * 0.1) * 0.5 + 0.5 # ノード位置で位相ずらし r = int(PATH_HIGHLIGHT[0] + (PATH_HIGHLIGHT_PULSE[0] - PATH_HIGHLIGHT[0]) * pulse_factor) g = int(PATH_HIGHLIGHT[1] + (PATH_HIGHLIGHT_PULSE[1] - PATH_HIGHLIGHT[1]) * pulse_factor) b = int(PATH_HIGHLIGHT[2] + (PATH_HIGHLIGHT_PULSE[2] - PATH_HIGHLIGHT[2]) * pulse_factor) color = (r, g, b) # 先端ノードのエフェクト if current_path_segment_index \u0026lt; len(path) and node == path[current_path_segment_index - 1]: if (frame_count // 4) % 2 == 0: # 点滅速度調整 color = PATH_HIGHLIGHT_PULSE # 先端にパーティクル (低確率) if random.random() \u0026lt; 0.15: # 確率少し上げる x = (node[1] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 y = (node[0] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 particles.append(Particle(x, y, PATH_HIGHLIGHT_PULSE, \u0026#34;fade_in\u0026#34;)) # 色を合わせる # --- 現在探索中のノード --- if solving and node == current_node: # 点滅エフェクト if (frame_count // 8) % 2 == 0: # 点滅速度調整 color = LIGHT_ORANGE else: color = ORANGE # --- スタートとゴール --- if node == start_node: color = GREEN elif node == end_node: # ゴール到達直後のフラッシュは goal_reached_flash フラグで管理せず、 # highlighting_path が True になった最初の数フレームだけ明るくするなど別の方法も検討可 # 現状はシンプルにREDのまま color = RED # --- セル描画 --- rect = pygame.Rect( (MARGIN + CELL_SIZE) * col + MARGIN, (MARGIN + CELL_SIZE) * row + MARGIN, CELL_SIZE, CELL_SIZE, ) pygame.draw.rect(screen, color, rect, border_radius=3) # --- 光沢とホバー効果 --- is_floor_like = (grid[row][col] == 0 or node == start_node or node == end_node or node in open_set_map or node in closed_set or is_path_node) if is_floor_like: # 光沢 highlight_rect = rect.copy() highlight_rect.height = max(1, CELL_SIZE // 4) # 少し小さく highlight_color = (min(255, color[0] + 40), min(255, color[1] + 40), min(255, color[2] + 40)) pygame.draw.rect(screen, highlight_color, highlight_rect, border_top_left_radius=3, border_top_right_radius=3) # ホバー if hover_cell == node: hover_rect = rect.inflate(-1, -1) # 枠線にかぶらないように hover_color = HOVER_COLOR # 固定色の方がわかりやすいかも # pygame.draw.rect(screen, hover_color, hover_rect, border_radius=2) # 塗りつぶし pygame.draw.rect(screen, hover_color, hover_rect, width=1, border_radius=2) # 枠線で表示 # --- 境界線 --- border_color = (max(0, color[0] - 50), max(0, color[1] - 50), max(0, color[2] - 50)) # より暗く pygame.draw.rect(screen, border_color, rect, 1, border_radius=3) frame_count += 1 # ここでframe_countをインクリメント # --- パーティクル更新と描画 --- active_particles = [] for p in particles: p.update(dt) # dt を渡して更新 # 寿命とサイズ（または波紋の最大サイズ到達）で生存判定 is_alive = p.age \u0026lt; p.lifespan if p.particle_type == \u0026#34;ripple\u0026#34;: # 波紋は寿命が来たら消える (max_sizeに達しても動き続ける) pass else: # 通常のパーティクルはサイズが0になったら消える is_alive = is_alive and p.size \u0026gt; 0 if is_alive: active_particles.append(p) particles = active_particles # 有効なパーティクルのみ残す # パーティクル描画用の透過Surfaceを作成 # SRCALPHAを使うことで、各パーティクルのアルファ値（透明度）が正しく扱われる particle_surface = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT), pygame.SRCALPHA) for p in particles: p.draw(particle_surface) # 透過Surfaceに描画 # screen（背景とセルが描画済み）の上にparticle_surfaceを重ねて描画 screen.blit(particle_surface, (0, 0)) # --- メッセージ表示 --- if message: text_color = WHITE stroke_color = BLACK msg_render = font.render(message, True, text_color) # ストローク描画 for dx, dy in [(-1,-1), (-1,1), (1,-1), (1,1), (-1,0), (1,0), (0,-1), (0,1)]: stroke_render = font.render(message, True, stroke_color) screen.blit(stroke_render, (10 + dx, WINDOW_HEIGHT - 25 + dy)) # 本体テキスト描画 screen.blit(msg_render, (10, WINDOW_HEIGHT - 25)) # --- 画面更新 --- pygame.display.flip() # goal_reached_flash のリセットはパーティクル生成直後に移動 # --- 終了処理 --- pygame.quit() ","date":"2025-03-30T05:18:12+09:00","image":"https://takoyakisoft.com/p/publish-pygame-web-hugo-pygbag/publish-pygame-web-hugo-pygbag_hu_5faf9495e623c6de.webp","permalink":"https://takoyakisoft.com/p/publish-pygame-web-hugo-pygbag/","title":"PygameゲームをWeb公開！pygbagとHugoでブログに簡単埋め込み (WebAssembly)"},{"content":"xAIに5ドル課金して毎月150ドル分のクレジットをもらう方法 以下の記事を参考にしてxAIに登録しました。\nGrok API にて $5 課金すると $150 分使えるようになるらしい？\nxAI Cloud Consoleに行きます。\nこの画像の1、2の順番でクリックして「Billing address」を入力します。\n画像は例で、英語で記入しました。クレジットカードと同じ住所だと思います。 Tax ID TypeとTax Numberはオプションなので書きませんでした。 税金関係だろうけれど、わかりません。 次に「Payment methods」を入力します。\nPayPayのJCBカードで通りました。\n「Redeem Promo code」というプロモコードの入力欄がありましたが、2月20日ではxAIのDeepResearchをしても見つかりませんでした。多分ないようです。 「Purchase credits」からクレジットを購入します。\n5ドルで大丈夫でした。 5ドルを課金すると「Share Data」ボタンが表示されますが、スクショを取り忘れました。 次の記事にあるように、xAIとデータを共有する代わりに毎月150ドル分のクレジットがもらえるようです。\nGet $150 in free API credits each month\nVSCodeの拡張機能でxAIを使う方法 CodyでGrokのAPIを使う Cody: AI Code AssistantはAIを使ったコード補完やコード編集、チャットなどの拡張機能です。 コード補完がずっと無料で、コード編集とチャットは回数制限があります。 なので、コード編集とチャットにGrokのAPIを設定することで、たった5ドルで制限なしのAIエディターを使えるようになります。\n画像のように「ファイル」→「ユーザー設定」→「設定」から右上のアイコンから「settings.json」を開きます。 別の方法で「Ctrl」 + 「Shift」 + Pを押して「Preferences: Open Settings (JSON)」でも開けます。\n次のように\u0026quot;cody.dev.models\u0026quot;の中に追加したいモデルを設定します。grokはOpenAI互換のAPIなので\u0026quot;openai\u0026quot;を指定します。 ついでにDeepSeekとGeminiのAPIも設定しています。DeepSeekも格安で使えるAPIです。 GeminiはGoogleの提供するAPIで無料で使えます。（連続で使用すると制限があるため、複数使用しています。） \u0026quot;inputTokens\u0026quot;や\u0026quot;temperature\u0026quot;、\u0026quot;stream\u0026quot;は公式の例をそのまま使っています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \u0026#34;cody.dev.models\u0026#34;: [ { \u0026#34;provider\u0026#34;: \u0026#34;openai\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;grok-2-latest\u0026#34;, \u0026#34;inputTokens\u0026#34;: 131072, \u0026#34;outputTokens\u0026#34;: 8192, \u0026#34;apiKey\u0026#34;: \u0026#34;xai-xxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;temperature\u0026#34;: 0, \u0026#34;stream\u0026#34;: false, }, \u0026#34;apiEndpoint\u0026#34;: \u0026#34;https://api.x.ai/v1\u0026#34; }, { \u0026#34;provider\u0026#34;: \u0026#34;groq\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;deepseek-chat\u0026#34;, \u0026#34;inputTokens\u0026#34;: 128000, \u0026#34;outputTokens\u0026#34;: 8192, \u0026#34;apiKey\u0026#34;: \u0026#34;sk-xxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;temperature\u0026#34;: 0.6 }, \u0026#34;apiEndpoint\u0026#34;: \u0026#34;https://api.deepseek.com/chat/completions\u0026#34; }, { \u0026#34;provider\u0026#34;: \u0026#34;google\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;gemini-2.0-pro-exp-02-05\u0026#34;, \u0026#34;inputTokens\u0026#34;: 2097152, \u0026#34;outputTokens\u0026#34;: 8192, \u0026#34;apiKey\u0026#34;: \u0026#34;AIxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;temperature\u0026#34;: 1.0 } }, { \u0026#34;provider\u0026#34;: \u0026#34;google\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;gemini-2.0-flash-exp\u0026#34;, \u0026#34;inputTokens\u0026#34;: 1048576, \u0026#34;outputTokens\u0026#34;: 8192, \u0026#34;apiKey\u0026#34;: \u0026#34;AIxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;temperature\u0026#34;: 1.0 } }, ], \u0026#34;cody.edit.preInstruction\u0026#34;: \u0026#34;Please think thoughts in English. 出力は日本語で出力してください。\u0026#34;, \u0026#34;cody.chat.preInstruction\u0026#34;: \u0026#34;Please think thoughts in English. 出力は日本語で出力してください。\u0026#34;, } コード編集「\u0026ldquo;cody.edit.preInstruction\u0026rdquo;」とチャット「\u0026ldquo;cody.chat.preInstruction\u0026rdquo;」では、それぞれChatGPTでいうところのカスタムプロンプトを設定できます。\nClineでGrokのAPIを使う ClineはAIエージェントだと思います。ファイルの読み書きや新規作成、コマンドを実行したりします。何度もAPIとやり取りするためトークンが多くなります。\nClineは、画像のように「OpenAI Compatible」で設定できます。 設定が終わったら「Done」で保存します。\nRoo CodeでGrokのAPIを使う Roo Code (prev. Roo Cline)はClineからフォークした拡張機能です。 Clineより更新が速く機能が多いです。\nRoo Codeも、画像のように「OpenAI Compatible」で設定できます。 設定が終わったら「Done」で保存します。\n","date":"2025-02-20T00:00:00+09:00","image":"https://takoyakisoft.com/p/registering-xai-grok-api-and-using-it-with-vscode-extensions-cody-cline-roo-code/xai_payment_hu_caf0b26686df4180.webp","permalink":"https://takoyakisoft.com/p/registering-xai-grok-api-and-using-it-with-vscode-extensions-cody-cline-roo-code/","title":"xAI（Grok API）の登録とVSCode拡張機能（Cody、Cline、Roo Code）での使い方"},{"content":"YouTube動画 【無料】電子書籍のPDFをまるごとGoogle翻訳！ Google翻訳 次のURLからGoogle翻訳に行きます。 https://translate.google.co.jp/\n画像が翻訳できます。\n背景色で元の文字を消してから翻訳後の文章を書いてくれます。 「翻訳をダウンロード」で画像をダウンロードできます。\n10MBを超えたり、300ページを超えたりすると翻訳できないです。 以下の形式のファイルが翻訳できます。\n.docx .pdf .pptx .xlsx PDFsam Basic 次のURLからPDFsam Basicをダウンロードします。 https://pdfsam.org/download-pdfsam-basic/ 「Portable archive」をダウンロードしました。\n起動時にJavaの設定をしているようで「pdfsam.bat」ファイルから起動します。\nファイルサイズが10MBを超える場合に使用します。 「このサイズで分割」を5,6MBに指定してから分割するとよいです。 理由は、10MBで分割したときにGoogle翻訳がタイムアウトエラーを起こしたからです。\nページ数が300ページを超える場合に使用します。 「\u0026ldquo;n\u0026quot;ページごとに分割」を300に指定します。 もしタイムアウトする場合は、200や100と数値を下げていってください。\n分割されたPDFファイルを画像のようにドラッグアンドドロップします。\n「実行」で結合します。デフォルトネームがつけられるので、名前変更が必要です。\nPDFsam Visual 14日間の試用期間のみ使用できるので、おすすめしません。 しかし、文章のみのPDFの圧縮率が良かったため、紹介します。\n次のURLからPDFsam Visualをダウンロードします。 https://pdfsam.org/download-pdfsam-visual/ 「Portable archive 64-bit」をダウンロードしました。\n起動画面で「Compress」を選択します。\nここにPDFをドラッグアンドドロップします。\n設定は「BROWSE」で保存先フォルダを選んで「SAVE」で圧縮します。\niLovePDF 次のURLからiLovePDFの「PDF圧縮」に行きます。 https://www.ilovepdf.com/ja/compress_pdf\nここでPDFファイルをD\u0026amp;Dします。\n「最も高い圧縮率」を選んで「PDF圧縮」します。\n","date":"2024-11-24T17:00:00+09:00","image":"https://takoyakisoft.com/p/free-translate-entire-ebook-pdfs-with-google-translate/free-translate-entire-ebook-pdfs-with-google-translate_hu_6e991b2d48c69724.webp","permalink":"https://takoyakisoft.com/p/free-translate-entire-ebook-pdfs-with-google-translate/","title":"【無料】電子書籍のPDFをまるごとGoogle翻訳！"},{"content":"YouTube動画 【Steam Link】Minecraftをリモートプレイ！ノートPCでも快適プレイ ノートPCでの作業（Steam Linkを入れるクライアント側） 次のURLからSteam Linkをダウンロードします。 https://store.steampowered.com/remoteplay\nこの画像の位置からお手持ちのOSに合ったSteam Linkをダウンロードします。\nSteam Linkの対応OSは以下のとおりです。\niPhone、iPad、Apple TV（11.0以降） Android（5.0以降）スマホ、タブレット、テレビ Google PlayへのアクセスがないAndroidユーザー Raspberry Pi 3、3+、4 Windows Linux macOS Meta Quest 2、3、Pro Windowsの場合のインストールは、msiではなくsetup.exeが良いようです。お手持ちのPC環境に足りないソフトのチェックもしてくれるとのことです。\nインストールはすべて「Next」にしました。\nゲーミングPCでの作業（Steamを入れるホスト側） 「Steam」→「設定」→「Remote Play」→「Remote Playを有効にする」のトグルボタンをオンにします。\n「ゲーム」→「非Steamゲームをマイライブラリに追加」→「参照」からMinecraftのランチャーを追加します。 私の環境ではDドライブのため「D:\\XboxGames\\Minecraft Launcher\\Content\\gamelaunchhelper.exe」にありました。 開いたあと、「gamelaunchhelper」にチェックが入っていることを確認して「選択したプログラムを追加」します。\nノートPCからリモートプレイ（Steam Linkが入ったクライアント側） ※ノートPC側ではSteamは終了させてください。つながらなくなります。\nSteam Linkを起動します。 ファイアウォールの設定が出たら許可をします。 初回はゲーミングPC側でもOKボタンを押す必要があった思います。\nマウスカーソルが表示されないことがありました。 ゲーミングPC側に余ったマウスを接続すると表示されます。 また、Windows 11 Proならば、リモートデスクトップのログイン・ログオフをするとマウスカーソルが表示されました。\nMinecraftの設定で、マウスのRaw入力をオフにしたほうが良いです。 なぜかチェストを開いてマウスカーソルを動かしチェストを閉じたとき、その方向に視点移動することがありました。マウスのRaw入力のオフでなくなる思います。\n","date":"2024-11-20T17:00:00+09:00","image":"https://takoyakisoft.com/p/steam-link-play-minecraft-remotely-smooth-gameplay-on-your-laptop/steam-link-play-minecraft-remotely-smooth-gameplay-on-your-laptop_hu_b0d1360ca7a52d1c.webp","permalink":"https://takoyakisoft.com/p/steam-link-play-minecraft-remotely-smooth-gameplay-on-your-laptop/","title":"【Steam Link】Minecraftをリモートプレイ！ノートPCでも快適プレイ"}]