[{"content":"GitHub 模板 roblox-ts-rojo-template\n这是什么？ 这是一个使用 VSCode 为 Roblox (TypeScript) 开发的现代开发环境模板。\nVSCode 👉 Roblox Studio 同步: Rojo Linter: ESlint Formatter: Prettier 包管理器: pnpm ❗ Caution 虽然尚未确认其功能，但已包含了一些知名的包。\n\u0026ldquo;@rbxts/janitor\u0026rdquo; \u0026ldquo;@rbxts/profileservice\u0026rdquo; \u0026ldquo;@rbxts/replicaservice\u0026rdquo; \u0026ldquo;@rbxts/cmdr\u0026rdquo; \u0026ldquo;@rbxts/testez\u0026rdquo; ℹ️ Note 确认运行\n\u0026ldquo;@rbxts/react\u0026rdquo; \u0026ldquo;@rbxts/react-roblox\u0026rdquo; ℹ️ Warning 不包含 CI/CD。\n安装 💡 Tip 您可以通过点击 \u0026ldquo;Use this template\u0026rdquo; 按钮来使用。\n安装包 1 pnpm install 安装 VSCode 扩展 当您打开此项目时，VSCode 会提示您安装以下扩展，请进行安装。\nroblox-ts ESLint Prettier Rojo 使用方法 从 VSCode 启动 Rojo 1 pnpm run watch 按下“Ctrl + Shift + P”\n选择“Rojo: Open Menu”\nℹ️ Note 如果是首次使用，请启动 Roblox Studio 并安装 Roblox Studio 插件（Install Roblox Studio Plugin）。\n点击“▶ default.project.json”\n从 Roblox Studio 连接 Rojo “插件”选项卡\nRojo 功能区\n“Connect”按钮\n","date":"2025-06-22T00:00:00+09:00","image":"https://takoyakisoft.com/p/roblox-ts-template-for-modern-development/roblox-ts-template-for-modern-development_hu_a201222c2d03b0b2.webp","permalink":"https://takoyakisoft.com/zh-cn/p/roblox-ts-template-for-modern-development/","title":"使用 Roblox (TypeScript) 和 VSCode 的现代开发环境模板"},{"content":"GitHub 模板 roblox-rojo-wally-template\n这是什么？ 这是一个使用 VSCode 为 Roblox (Luau) 进行开发的现代开发环境模板。\n从 VSCode 同步到 Roblox Studio: Rojo 代码检查器 (Linter): Selene 代码格式化器 (Formatter): StyLua 包管理器 (Package Manager): Wally Rojo 和 Wally 的管理器: Rokit ℹ️ Warning 不包含 CI/CD: CI/CD\n安装 💡 Tip 您可以通过点击 “Use this template” 按钮来使用。\n安装 Rokit Windows (PowerShell)\n1 Invoke-RestMethod https://raw.githubusercontent.com/rojo-rbx/rokit/main/scripts/install.ps1 | Invoke-Expression macOS / Linux\n1 curl -fsSL https://raw.githubusercontent.com/rojo-rbx/rokit/main/scripts/install.sh | sh 安装 Rojo、Wally 等工具 1 2 3 rokit add rojo rokit add wally rokit add wally-package-types 安装包 1 2 3 4 5 wally install rojo sourcemap default.project.json --output sourcemap.json wally-package-types -s sourcemap.json Packages/ wally-package-types -s sourcemap.json ServerPackages/ wally-package-types -s sourcemap.json DevPackages/ 安装 VSCode 扩展 在 VSCode 中打开此项目时，会提示安装以下扩展，请进行安装。\nRojo Luau Language Server Selene StyLua 使用方法 从 VSCode 启动 Rojo “Ctrl + Shift + P”\n“Rojo: Open Menu”\nℹ️ Note 如果是首次使用，请启动 Roblox Studio 并安装 Roblox Studio 插件（Install Roblox Studio Plugin）。\n“▶ default.project.json”\n从 Roblox Studio 连接 Rojo “插件” (Plugins) 选项卡\n“Rojo” 功能区\n“Connect” 按钮\n向 Wally 添加包 在 VSCode 中编辑 wally.toml 文件。\n请访问 wally.run 网站，查找您需要的包，并通过“Install”复制其名称。\n各个部分的分类如下：\n[dependencies] 用于客户端和服务器\n[server-dependencies] 仅用于服务器\n[dev-dependencies] 仅用于开发和测试\n编辑完成后，请再次执行安装包的步骤。\n参考资料 How Big Studios Develop on Roblox\n","date":"2025-06-21T00:00:00+09:00","image":"https://takoyakisoft.com/p/roblox-luau-template-for-modern-development/roblox-luau-template-for-modern-development_hu_a201222c2d03b0b2.webp","permalink":"https://takoyakisoft.com/zh-cn/p/roblox-luau-template-for-modern-development/","title":"Roblox (Luau) 与 VSCode 的现代开发环境模板"},{"content":"大家好！\n顺便说一句，这篇文章也是在 Rovo Dev CLI 的 AI 助手功能帮助下写成的。很方便吧！\n这次，我将为大家介绍由 Atlassian 开发的 AI 助手工具“Rovo Dev CLI”。\n这是一款类似于热门工具“Claude Code”的工具。你可以在终端上与 AI 对话，让它帮助你编码、创建测试、进行重构等等，用途非常广泛。而且，目前它正处于 Beta 测试阶段，可以免费使用。\n不过，在 Windows 的 PowerShell 中直接使用时，日文会出现乱码……\n但别担心！ 本文将从基本用法讲起，介绍如何使用“WSL2”和“VSCode”完美解决乱码问题，甚至还会介绍如何利用“MCP 联动”功能让 AI 指挥 3D 建模，并附上具体的操作步骤。\nRovo Dev CLI 是什么？ Rovo Dev CLI 是由开发了 Jira 和 Confluence 的知名公司 Atlassian 开发的一款命令行 AI 助手。\n我亲自问了 Rovo Dev 本人“你用的是哪个模型？”，它回答说用的是 Anthropic 公司的 Claude 系列模型。\nWindows 用户请从这里开始！WSL2 的设置 如果你在 Windows 上使用 Rovo Dev CLI，我强烈推荐使用 WSL2 (Windows Subsystem for Linux 2)。 正如刚才所说，这是因为直接在 PowerShell 中使用时，日文会显示为乱码。\nWSL2 的安装与配置 安装 WSL2 打开“PowerShell”，执行以下命令。\n1 wsl --install -d Ubuntu-24.04 在我的环境中，需要重启一次电脑才能让 WSL 正常启动。如果你的也无法运行，可以试试这个方法。\nWSL2 的初始设置 安装完成后，Ubuntu 会启动，这时请设置你的用户名和密码。\n配置便捷的镜像网络模式 设置 WSL2 的新功能“镜像模式”后，Windows 和 WSL2 之间将共享网络，无论在哪一边都可以通过“localhost”访问。 这对于后面要介绍的 MCP 联动功能来说非常方便。\n在你的 Windows 用户文件夹（C:\\Users\\你的用户名）中创建一个名为 .wslconfig 的文件，并写入以下内容。\n1 2 [wsl2] networkingMode=mirrored 你也可以通过菜单中的“WSL Settings”完成同样的操作。\n重启 WSL2 为了让设置生效，请在 PowerShell 中执行此命令。\n1 wsl --shutdown 之后，请再次启动 WSL2（Ubuntu）。\n这样，WSL2 的环境就准备好了。 下一步，我们将从 VSCode 连接到这个 WSL2 环境，以便更舒适地进行操作。\n从 VSCode 连接到 WSL2 接下来的所有操作，我们都将通过 VSCode 的 WSL 扩展来完成。\nVSCode WSL 扩展的安装与连接步骤 安装 VSCode 如果你还没有安装，请从官方网站下载并安装。\n安装 WSL 扩展 启动 VSCode，在左侧的扩展标签页（Ctrl+Shift+X）中搜索“WSL”并安装。\n连接到 WSL2 点击 VSCode 窗口左下角的绿色图标，选择“连接到 WSL\u0026hellip;”。 选择 Ubuntu-24.04 选择刚才安装的 Ubuntu-24.04。\n打开终端 从 VSCode 菜单中选择“终端”→“新建终端”，或者使用快捷键 Ctrl+` 来打开终端。 像图中那样打开也可以。 现在，从 VSCode 访问 WSL2 的 Ubuntu 的准备工作就完成了！ 接下来的操作，我们都在这个 VSCode 内的终端里进行。 编辑和创建文件也可以使用 VSCode 的编辑器，非常方便。\n安装与初始设置 安装 ACLI (Atlassian CLI) Rovo Dev 是通过一个名为 ACLI 的 Atlassian 通用工具来使用的。首先，我们把它安装到 WSL2 的 Ubuntu 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 安装必要的软件包 sudo apt-get install -y wget gnupg2 # 配置 APT 仓库 # 创建用于存放密钥的目录 sudo mkdir -p -m 755 /etc/apt/keyrings # 下载公钥并转换为 GPG 格式 wget -nv -O- https://acli.atlassian.com/gpg/public-key.asc | sudo gpg --dearmor -o /etc/apt/keyrings/acli-archive-keyring.gpg # 设置密钥文件的权限 sudo chmod go+r /etc/apt/keyrings/acli-archive-keyring.gpg # 将仓库信息添加到 APT 配置中 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/acli-archive-keyring.gpg] https://acli.atlassian.com/linux/deb stable main\u0026#34; | sudo tee /etc/apt/sources.list.d/acli.list \u0026gt; /dev/null # 安装 ACLI sudo apt update sudo apt install -y acli 如果你使用其他操作系统，可以参考官网的Install and update页面上的步骤。\n获取 Atlassian API 令牌并进行认证 接下来，我们去获取用于登录 Atlassian 账户的 API 令牌。\n访问 Atlassian ID 个人资料。 点击“Create API token”，为令牌起一个容易识别的名字（比如 rovo-dev-cli），然后创建令牌。 生成的令牌只会显示一次，请务必复制并保存在某个地方！ 令牌准备好后，在终端中执行此命令进行认证。\n1 acli rovodev auth login 输入你的电子邮箱地址，然后粘贴刚才复制的 API 令牌，即可完成认证。\n启动！ 好了，终于要启动 AI 助手了。\n1 acli rovodev run 执行此命令后，终端将切换到与 AI 的对话模式。是不是很激动人心！\n了解这些会更方便！基本用法 Rovo Dev CLI 提供了许多能让开发工作变得轻松愉快的功能。\n自定义提示（自定义指令） 每次都重复提同样的要求，是不是有点麻烦？在这种时候，自定义提示功能就非常方便了。你可以预先告诉 AI一些背景知识。设置方式类似于 Claude 桌面版的 CLAUDE.md。\n有三种设置方法：\n全局配置文件 在 ~/.rovodev/config.yml 中像这样写入。这是对整个电脑都有效的指令。 1 2 3 4 additionalSystemPrompt: | 你是 Python 和 TypeScript 的专家。 编写代码时，请务必包含测试。 请用简洁的中文进行说明。 全局 Agent 文件 在 ~/.rovodev/.agent.md 文件中，写入想让 AI 读取的指令。由于是 Markdown 格式，你可以写得更详细。 1 2 3 4 5 6 7 8 9 10 # 开发者指南 ## 编码风格 - 使用 2 个空格进行缩进 - 函数名使用 camelCase - 类名使用 PascalCase ## 测试方针 - 单元测试是必须的 - 活用 mock 来加速测试 项目特定指令 在你正在工作的仓库根目录下创建一个 .agent.md 文件。这对于编写团队共享的规则非常方便。个人设置可以写在 .agent.local.md 中，这样可以被 Git 忽略，我非常推荐。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 项目特定指南 本项目是使用 Next.js 和 TypeScript 开发的 Web 应用。 ## 架构 - pages/ - 用于路由的页面组件 - components/ - 可复用的 UI 组件 - lib/ - 工具函数和助手函数 - styles/ - CSS 模块和全局样式 ## 开发规则 - 组件应使用函数式组件创建 - 状态管理使用 React Hooks - API 请求使用 SWR 所有这些设置都可以组合使用，AI 会综合考虑所有指令来回答你。通过编写有效的自定义指令，你可以从 AI 那里获得更高质量的回答。\n命令示例 在对话模式中，你可以这样提问。\nsummarize this file ./path/to/file.js: 总结一下这个文件！ add unit tests for UserService: 为 UserService 编写单元测试！ Refactor this complex function to be more readable: 把这个复杂的函数重构得更容易阅读！ AI 能够正确理解目录结构，所以只需传递文件路径，它就能理解上下文，这点非常聪明。\n对话模式中的实用命令列表 对话模式中还有很多其他方便的命令。它们能让你与 AI 的交流更加顺畅。如果你想了解某个命令的详细用法，可以在对话模式中输入 /命令名 help。\n会话管理 /sessions 管理会话的命令。使用它，你可以将对话历史和上下文分开保存，非常方便。\n主要功能: 会话管理：可以创建和切换多个对话会话。 上下文保持：每个会话都会记住各自的对话历史。 工作区分离：可以为每个项目分别创建会话。 会话分支：还可以从当前对话中分支出一个新的会话。 重启 Rovo Dev CLI 时，加上 --restore 选项，它会自动恢复上一个会话。\n清除会话 /clear 将当前会话的对话历史全部清除，恢复到初始状态。请注意，此操作无法撤销。如果想保留历史记录，可以使用 /sessions 命令创建一个新会话，或者使用接下来介绍的 /prune 命令。\n优化会话 /prune 当对话变得越来越长时，可以使用这个命令。它是一个聪明的命令，能在保留重要内容的同时节省 Token。它会删除 AI 执行的工具（程序）的结果等，从而精简历史记录。\n预定义指令模板 /instructions 对于像代码审查或文档编写这类常见任务，你可以执行预先准备好的指令模板。\n内置指令模板: 代码审查与分析 文档生成与改进 单元测试创建与覆盖率提升 总结 Confluence 页面 分析 Jira 问题 你也可以创建自己的自定义模板！\n在 .rovodev/instuctions.yml 中创建指令文件。 在 .rovodev 文件夹中，创建一个 Markdown 文件，写入指令内容。 使用方法很简单，输入 /instructions 就会显示模板列表。\n内存管理 /memory 这是一个让 Rovo Dev CLI 记住有关项目和设置的重要信息的功能。\n内存类型: 项目内存：保存在当前目录中。（.agent.md 和 .agent.local.md） 用户内存：全局保存在主目录中。（~/.rovodev/agent.md） 内存文件是 Markdown 格式的，可以用来记录项目规则或编码规范等，非常方便。 像 # 想记录的事情 这样写，就可以快速添加笔记。\n反馈 /feedback 用于发送关于 Rovo Dev CLI 的感想或 Bug 报告的命令。\n使用情况 /usage 可以查看今天 LLM 的 Token 使用量。检查一下有没有用超！\n退出 /exit 退出应用程序。使用 /quit 或 /q 效果相同。\n【高级篇】WSL2 与 Windows 之间的联动 得益于 VSCode 的 WSL 扩展，WSL2 和 Windows 之间的文件共享与应用联动变得非常顺畅。\n活用镜像网络模式 我们一开始设置的 WSL2 镜像网络模式，在这里将大显身手。\n端口共享：你可以直接从 Windows 的浏览器访问在 WSL2 中启动的服务器（例如 localhost:3000）。 网络服务共享：Windows 和 WSL2 都可以使用同一网络上的服务。 与 MCP 服务器的联动：这个功能在接下来要介绍的 MCP 联动中尤为重要。它使得 WSL2 的 Rovo Dev CLI 能够无缝连接到在 Windows 上运行的 Blender 的 MCP 服务器。 благодаря этой интеграции вы можете получить лучшее из обоих миров: удобный интерфейс Windows и мощную командную строку Linux. (Note: A Russian sentence was in the original thought process. Translating the intended meaning.) 得益于这种联动，你可以集 Windows 方便的图形界面和 Linux 强大的命令行于一身，取两家之长。\n【应用篇】用 MCP 让 AI 操作 Blender！ 终于到了最后一步！让我们使用 Rovo Dev 的强大功能——MCP (Model Context Protocol)，从 WSL2 控制 Windows 上的 Blender。这次，我们将使用一个名为 BlenderMCP 的便利开源工具。\nBlenderMCP 是什么？ BlenderMCP 是一个连接 AI 和 Blender 的工具。使用它，AI 就能直接操作 Blender，完成 3D 建模、场景创建、物体操作等任务！\n主要功能\n双向通信：连接 AI 和 Blender 物体操作：可以创建、移动、删除物体 材质控制：可以上色、设置质感 场景检查：AI 可以确认当前 Blender 中的状态 代码执行：AI 可以向 Blender 发送并执行 Python 代码 设置步骤 BlenderMCP 由两个部分组成。\nWindows 端：Blender 插件 (addon.py)：安装在 Windows 的 Blender 中 WSL2 端：MCP 服务器：安装在 WSL2 的 Ubuntu 中，供 Rovo Dev CLI 使用 那么，我们开始设置吧！\nWindows 端：安装 Blender 插件\n从 BlenderMCP 的 GitHub 仓库 下载 addon.py 文件 打开 Blender，进入“编辑”\u0026gt;“偏好设置”\u0026gt;“插件” 点击“从磁盘安装\u0026hellip;”，选择下载的 addon.py 文件 勾选“Blender MCP”旁边的复选框，启用该插件 WSL2 端：安装 uv 包管理器\n在 WSL2 的 Ubuntu 终端中，执行此命令 1 2 # 安装 uv 包管理器 curl -LsSf https://astral.sh/uv/install.sh | sh WSL2 端：配置 Rovo Dev CLI\n使用 VSCode 编辑配置文件 1 2 export EDITOR=\u0026#34;code\u0026#34; acli rovodev mcp 这时 VSCode 会打开配置文件，请添加以下内容。这个设置是为了让 Rovo Dev CLI 启动时自动运行 BlenderMCP。 1 2 3 4 5 6 7 8 { \u0026#34;mcpServers\u0026#34;: { \u0026#34;blender\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;uvx\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;blender-mcp\u0026#34;] } } } Windows 端：在 Blender 中进行连接设置\n在 Blender 界面中，打开 3D 视图的侧边栏（如果未显示，请按 N 键） 找到名为“BlenderMCP”的标签页，点击“Connect to MCP server” WSL2 端：用 Rovo Dev CLI 操作 Blender！\n在 WSL2 的 VSCode 集成终端中执行 acli rovodev run 试着向 AI 这样提问： 1 使用 Blender 创建一只猫。 结果如何呢？来自 WSL2 的指令，应该会让正在 Windows 上运行的 Blender 画面中出现一个立方体，并向上移动。这就是我们最初设置的镜像网络模式的力量。WSL2 将在 Windows 上运行的 Blender 识别为“localhost 上的服务器”，从而实现了无缝联动。太棒了！\nMCP 故障排除 如果无法正常工作，请检查以下几点：\n连接问题：Blender 插件是否已启用？是否在 Blender 的 MCP 标签页中点击了“Connect to MCP server”？ WSL2 镜像网络模式：请确认镜像模式是否已正确启用。 尝试重启：如果连接错误持续出现，最简单的办法可能是重启 Rovo Dev CLI 和 Blender。 命令执行方式：请不要直接执行 uvx blender-mcp 命令。Rovo Dev CLI 会根据配置文件自动执行它。 最重要的一点是，确保 WSL2 和 Windows 之间的网络连接已正确设置为镜像模式。\n总结 本文从 Atlassian 的新款 AI 开发工具“Rovo Dev CLI”的基本用法，到 Windows 用户舒适使用它的 WSL2 活用技巧，再到使用 MCP 进行 Blender 联动，内容广泛地进行了介绍。\n虽然一开始的设置可能有些繁琐，但一旦环境搭建完成，那种足不出终端就能获得 AI 强大支持的开发体验，我认为真的是革命性的。\nRovo Dev CLI 目前仍处于 Beta 版，我很期待它未来的发展和进化。 希望这篇文章能帮助大家找到新的开发方式。\n请务必尝试一下这款未来的工具。Happy coding! 🎉\n","date":"2025-06-19T15:05:00+09:00","image":"https://takoyakisoft.com/p/rovo-dev-cli-guide-wsl2-blender/rovo-dev-cli-guide-wsl2-blender_hu_79a0b353e74edfc1.webp","permalink":"https://takoyakisoft.com/zh-cn/p/rovo-dev-cli-guide-wsl2-blender/","title":"Rovo Dev CLI实战指南：如何在VSCode与WSL2中舒适地使用"},{"content":"大家好！这次，我将分享一下使用名为mastra的库来运行Grok-2和Gemini 2.5 Pro exp等LLM的经验。\nmastra是一个库，它允许你决定使用哪个LLM来创建“AI代理”，并构建这些代理按何种顺序运行的“工作流”。对我个人来说，可以用TypeScript编写这一点非常吸引人，我认为这样或许可以将其廉价地集成到Cloudflare Workers或Deno等环境中的Web服务中。\n虽然有像LangChain这样类似且著名的库，但mastra在部署便利性方面可能略有优势。另外，之前我试用过的名为Dify的工具，在处理重复操作（循环）方面感觉有些不擅长，所以我想试试mastra会怎么样，这也是尝试的背景之一。\n那么，我们马上开始试试吧！\n安装 mastra 这次我将在Windows 11上，使用AI编辑器“Trae”和高速包管理器“pnpm”。\n首先，按照mastra官网上的步骤创建项目。 （参考：Create a New Project）\n打开终端，执行以下命令。\n1 pnpm create mastra@latest 会问几个问题，我们来回答一下。\n询问项目名称。这次我命名为 my-mastra-app。\n1 2 ◇ What do you want to name your project? │ my-mastra-app 询问源文件的存放位置。默认的 src/ 就可以了。\n1 2 ◆ Where should we create the Mastra files? (default: src/) │ src/ 选择需要的组件。Agents（代理）、Workflows（工作流）和Tools（工具）之后会用到，所以选 Yes 吧。\n1 2 3 4 5 ◆ Choose components to install: │ ◼ Agents │ ◼ Workflows ◇ Add tools? │ Yes 选择默认使用的LLM提供商。这次我选择了Google，但这个之后可以自由更改。\n1 2 ◇ Select default provider: │ Google API密钥的设置。之后会在 .env.development 文件中设置，所以这里选择跳过（Skip for now）没关系。\n1 2 ◆ Enter your google API key? │ ● Skip for now (default) 是否添加示例，这次选择 Yes。\n1 2 ◇ Add example │ Yes 与AI IDE的集成，这次也跳过了。\n1 2 ◇ Make your AI IDE into a Mastra expert? (installs Mastra docs MCP server) │ Skip for now 这样项目的模板就创建好了！ 移动到创建的项目文件夹，安装所需的库。\n1 2 cd my-mastra-app pnpm i 启动开发服务器。可以用Ctrl+C停止。\n1 pnpm run dev 查看设置 安装完成后，我们来看几个文件吧。\n查看 package.json，可以看到 dependencies 里有 @ai-sdk/google。这是Vercel公司提供的库，看起来不仅支持Gemini，还支持DeepSeek、Grok、OpenRouter等其他LLM提供商。感觉很方便呢！ （参考：AI SDK Providers）\nscripts 里只有 dev。也许将来会添加用于构建或测试的脚本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;name\u0026#34;: \u0026#34;my-mastra-app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;mastra dev\u0026#34; }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;@ai-sdk/google\u0026#34;: \u0026#34;^1.2.5\u0026#34;, \u0026#34;@mastra/core\u0026#34;: \u0026#34;^0.7.0\u0026#34;, \u0026#34;mastra\u0026#34;: \u0026#34;^0.4.4\u0026#34;, \u0026#34;zod\u0026#34;: \u0026#34;^3.24.2\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/node\u0026#34;: \u0026#34;^22.14.0\u0026#34;, \u0026#34;tsx\u0026#34;: \u0026#34;^4.19.3\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^5.8.2\u0026#34; } } 这次我们还想使用xAI的Grok，所以添加相应的库。\n1 pnpm add @ai-sdk/xai 如果不再需要，可以用 pnpm remove @ai-sdk/xai 删除。\n接下来是API密钥的设置。在项目根目录下创建名为 .env.development 和 .env 的文件，并分别写入各自的API密钥。（.env 用于生产环境，.env.development 用于开发环境）\n.env.development:\n1 2 GOOGLE_GENERATIVE_AI_API_KEY=your-google-api-key XAI_API_KEY=your-xai-api-key 如果想更改LLM模型，可以在定义代理的文件（例如 src/mastra/agents/index.ts）或工作流文件（例如 src/mastra/workflows/index.ts）中指定。\n例如，使用Grok-2的情况是这样的。\nsrc/mastra/agents/index.ts 示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { xai } from \u0026#39;@ai-sdk/xai\u0026#39;; // 导入 xAI 库 import { Agent } from \u0026#39;@mastra/core/agent\u0026#39;; import { weatherTool } from \u0026#39;../tools\u0026#39;; // 也导入要使用的工具 export const weatherAgent = new Agent({ name: \u0026#39;Weather Agent\u0026#39;, instructions: ` You are a helpful weather assistant that provides accurate weather information. Your primary function is to help users get weather details for specific locations. When responding: - Always ask for a location if none is provided - If the location name isn’t in English, please translate it - If giving a location with multiple parts (e.g. \u0026#34;New York, NY\u0026#34;), use the most relevant part (e.g. \u0026#34;New York\u0026#34;) - Include relevant details like humidity, wind conditions, and precipitation - Keep responses concise but informative Use the weatherTool to fetch current weather data. `, model: xai(\u0026#39;grok-2-latest\u0026#39;), // 在这里指定模型！ tools: { weatherTool }, }); 在工作流中也可以同样指定。\nsrc/mastra/workflows/index.ts 示例:\n1 2 3 4 5 6 import { xai } from \u0026#39;@ai-sdk/xai\u0026#39;; import { Agent } from \u0026#39;@mastra/core/agent\u0026#39;; import { Step, Workflow } from \u0026#39;@mastra/core/workflows\u0026#39;; import { z } from \u0026#39;zod\u0026#39;; const llm = xai(\u0026#39;grok-2-latest\u0026#39;); // 在这里定义要使用的模型 确认运行情况 设置完成后，我们再启动一次开发服务器吧。\n1 pnpm run dev 在浏览器中访问 http://localhost:4111/，应该会显示mastra的界面。\n可以选择代理，用聊天形式试试呢。\n使用Grok-2时，有时会返回英文回答。\n实现“think工具” 接下来，我们来实现一个有点意思的工具，叫做“think工具”。\n这是Anthropic文章中介绍的一种技巧，据说在让LLM执行某项操作之前加入一个“思考”步骤，可以提高性能。 （参考：The \u0026ldquo;think\u0026rdquo; tool: Enabling Claude to stop and think in complex tool use situations）\n这个工具本身并不获取任何外部信息，仅仅是模仿“思考”这个过程。但是，据说这样能在需要复杂推理的情况下产生效果。很有趣吧！\n那么，我们用mastra来创建think工具吧。\n首先，创建一个定义工具的文件。\nsrc/mastra/tools/thinkTool.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { createTool } from \u0026#39;@mastra/core/tools\u0026#39;; import { z } from \u0026#39;zod\u0026#39;; // 用于输入数据验证 export const thinkTool = createTool({ id: \u0026#39;think\u0026#39;, // 工具的ID description: \u0026#39;Use the tool to think about something. It will not obtain new information or change the database, but just append the thought to the log. Use it when complex reasoning or some cache memory is needed.\u0026#39;, // 工具的描述 inputSchema: z.object({ // 工具接收的输入的定义 thought: z.string().describe(\u0026#39;A thought to think about.\u0026#39;), }), outputSchema: z.object({}), // 工具输出的数据的定义（这次为空） execute: async ({ context }) =\u0026gt; { // 实际处理什么也不做 console.log(\u0026#39;Thinking:\u0026#39;, context.thought); // 或许可以在控制台输出思考内容 return {}; }, }); 接下来，创建使用这个think工具的代理。关键在于通过提示指示何时应该使用think工具呢。\nsrc/mastra/agents/thinkAgent.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { Agent } from \u0026#39;@mastra/core/agent\u0026#39;; import { thinkTool } from \u0026#39;../tools/thinkTool\u0026#39;; // 导入创建的 thinkTool import { xai } from \u0026#39;@ai-sdk/xai\u0026#39;; // 也导入要使用的LLM模型 export const thinkAgent = new Agent({ name: \u0026#39;Think Agent\u0026#39;, instructions: ` ## Using the think tool Before taking any action or responding to the user after receiving tool results, use the think tool as a scratchpad to: - List the specific rules that apply to the current request - Check if all required information is collected - Verify that the planned action complies with all policies - Iterate over tool results for correctness Here are some examples of what to iterate over inside the think tool: \u0026lt;think_tool_example_1\u0026gt; User wants to [specific scenario] - Need to verify: [key information] - Check relevant rules: [list rules] - Verify [important conditions] - Plan: [outline steps] \u0026lt;/think_tool_example_1\u0026gt; `, model: xai(\u0026#39;grok-2-latest\u0026#39;), // 这里也试试用Grok-2吧 tools: { thinkTool } // 注册为该代理使用的工具 }); 最后，将创建的工具和代理注册到mastra。\nsrc/mastra/index.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Mastra } from \u0026#39;@mastra/core/mastra\u0026#39;; import { createLogger } from \u0026#39;@mastra/core/logger\u0026#39;; import { weatherWorkflow } from \u0026#39;./workflows\u0026#39;; import { weatherAgent } from \u0026#39;./agents\u0026#39;; import { thinkAgent } from \u0026#39;./agents/thinkAgent\u0026#39;; // 导入创建的 thinkAgent export const mastra = new Mastra({ workflows: { weatherWorkflow }, // 现有的工作流 agents: { weatherAgent, thinkAgent }, // 添加代理 logger: createLogger({ name: \u0026#39;Mastra\u0026#39;, level: \u0026#39;info\u0026#39;, }), }); 这样 think 工具的实现就完成了！\nthink工具的运行确认 再次启动开发服务器来确认一下吧。\n1 pnpm run dev 访问 http://localhost:4111/，这次请选择“Think Agent”。\n发出一些指示后，think 工具应该会在后台运行，然后给出回应。\n这样一来，即使是稍微复杂的事情，也许也能更准确地思考了！\n实现创建文章克隆提示的工作流 那么，从这里开始，我们来挑战一下结合mastra的循环功能和评估功能的稍微进阶的工作流吧！\n这个工作流的目标：让 AI 学习“自己的文风” 主题是“让AI自己创建模仿给定文章写作风格的AI提示”。总觉得像是让AI思考如何使用AI，不觉得这是一个有趣的尝试吗？\n最近，也经常听到“分不清是AI写的文章还是人写的文章！”这样的话吧。既然如此，干脆让AI学习自己文章的习惯，让它帮忙写博客文章的草稿之类的，不就能减少打字量，变得更轻松了吗？这就是我尝试创建这个工作流的契机。\n准备：添加评估库和注册工作流 首先是准备：添加评估库\n在这个工作流中，为了让另一个AI评估生成的提示的好坏，我们将使用mastra的评估库。在终端执行以下命令进行安装。\n1 pnpm add @mastra/evals 将工作流注册到mastra\n接下来，为了让 mastra 本体识别我们将要创建的工作流 (clonePromptGeneratorWorkflow)，我们更新配置文件 (src/mastra/index.ts)。\nsrc/mastra/index.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Mastra } from \u0026#39;@mastra/core/mastra\u0026#39;; import { createLogger } from \u0026#39;@mastra/core/logger\u0026#39;; import { weatherWorkflow } from \u0026#39;./workflows\u0026#39;; // ↓ 导入新的工作流 import { clonePromptGeneratorWorkflow } from \u0026#39;./workflows/clonePromptGeneratorWorkflow\u0026#39;; import { weatherAgent } from \u0026#39;./agents\u0026#39;; import { thinkAgent } from \u0026#39;./agents/thinkAgent\u0026#39;; export const mastra = new Mastra({ // ↓ 将新的工作流添加到 workflows 对象 workflows: { weatherWorkflow, clonePromptGeneratorWorkflow }, agents: { weatherAgent, thinkAgent }, logger: createLogger({ name: \u0026#39;Mastra\u0026#39;, level: \u0026#39;info\u0026#39;, }), }); 这样准备就绪了！\nAI改进提示的机制：处理流程解说 那么，我们来看看实际上是以怎样的流程让AI生成和改进提示的吧。\n提示创建AI (Prompt Creator Agent): 首先，让它分析你准备的作为“范本”的文章 (originalText)。然后，捕捉该文章作者的特征（人格、文风、口头禅等），创建用于指示其他AI“请模仿这个人来写文章！”的“模仿指示提示”的初版。\n主题提取AI (Theme Abstractor Agent): 接下来，从范本文章中去除具体的专有名词（如 mastra、Grok-2 等），提取出像“使用软件工具包创建 AI 处理流程的步骤”这样的一般性的“抽象主题”。这是为了在测试模仿程度时，避免生成与范本完全相同的内容。\n文章生成AI (Text Generator Agent): 使用步骤1中创建的“模仿指示提示”和步骤2中提取的“抽象主题”，让它实际生成模仿文章。大概就是“关于‘抽象主题’，请按照模仿指示提示来写”这样的感觉。\n评估AI (Authorship Similarity Judge/Metric): 终于到了评估环节。让它比较范本文章和步骤3中 AI 生成的模仿文章，以 0.0（完全不像）到 1.0（一模一样！）的分数来评定“写作风格的相似度”。只看“写作风格”，比如词语选择、句子长度、语气、标点符号用法等，不问内容的正确性。\n循环判断 \u0026amp; 反馈:\n如果评估分数超过预先设定的阈值（在代码中设为 SIMILARITY_THRESHOLD = 0.7），则视为“合格！”，工作流结束，并输出成功的“模仿指示提示”。 如果分数未达到阈值，则表示“还需要努力”。评估 AI 创建指出“分数为何低（例如：标点符号用法更不像、语气太生硬等）”的反馈，并将该反馈附加到步骤1的提示创建 AI，指示“请参考这个反馈，创建更好的提示！”，然后进行循环。 通过重复这个循环，AI 在不断试错中，逐渐改进为能够生成越来越接近范本写作风格的文章的“模仿指示提示”，就是这样的机制。\n提示:\n模型选择: 这次的代码中使用了 xai('grok-2-latest')，但如果你可以通过 Google AI Studio 等访问 gemini('gemini-2.5-pro-exp-03-25') 这样的更高性能模型，尝试一下，或许一次循环就能得到相当好的结果！请尝试修改各个 Agent 或 Metric 的 model: llm 部分。 相似度分数阈值: SIMILARITY_THRESHOLD 的值 (0.7) 是评估严格程度的标准。如果循环迟迟不结束，可以尝试稍微降低一点，如果想提高精度，可以尝试提高一点，请手动调整试试看。 运行试试！工作流执行步骤 在开发服务器 (pnpm run dev) 启动的状态下，从浏览器访问 http://localhost:4111/。\n从左侧菜单中选择“Workflows”，然后选择这次创建的 clone-prompt-generator-workflow-with-eval。\n右侧名为“Run”的选项卡中应该会显示一个名为 OriginalText 的输入字段。在这里，粘贴你想要作为范本的文章（例如，过去写的博客文章的一部分等）。\n粘贴文章后，点击“Submit”按钮！\n之后，就请关注终端（或 VS Code 等的 OUTPUT 面板）中滚动的日志吧。每次循环时，应该会显示评估分数和反馈。\n完整的工作流代码 实际运行的工作流代码如下所示。\nsrc/mastra/workflows/clonePromptGeneratorWorkflow.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 import { xai } from \u0026#39;@ai-sdk/xai\u0026#39;; // 或者使用 gemini, openai 等 // import { gemini } from \u0026#39;@ai-sdk/google\u0026#39;; // 使用 Gemini 的示例 import { Agent } from \u0026#39;@mastra/core/agent\u0026#39;; import { Step, Workflow } from \u0026#39;@mastra/core/workflows\u0026#39;; import { z } from \u0026#39;zod\u0026#39;; import { type LanguageModel } from \u0026#39;@mastra/core/llm\u0026#39;; import { MastraAgentJudge } from \u0026#39;@mastra/evals/judge\u0026#39;; import { Metric, type MetricResult } from \u0026#39;@mastra/core/eval\u0026#39;; // --- 配置 --- // 使用的LLM模型（根据需要更改） const llm = xai(\u0026#39;grok-2-latest\u0026#39;); // const llm = gemini(\u0026#39;gemini-2.5-pro-exp-03-25\u0026#39;); // 使用 Gemini 2.5 Pro Experimental 的示例 // 判定为同一人物的相似度分数阈值（可调整） const SIMILARITY_THRESHOLD = 0.7; // 存储对提示创建 AI 的反馈的变量 let feedbackForPromptCreator = \u0026#34;\u0026#34;; // 循环计数器 let iteration = 0; // --- 评估相关定义 --- /** * 生成传递给评估 AI 的提示的函数 */ const generateSimilarityPrompt = ({ originalText, generatedText, }: { originalText: string; generatedText: string; }) =\u0026gt; ` 您是一位比较分析文章写作风格的专家。 请比较给定的“范本文章”和“AI生成的文章”，评估两者是否**看起来像是同一个人写的**。 **评估标准：** 请关注以下要素，判断综合的写作风格相似度。 * **文风：** 第一人称、语气（敬语、随便等）、句尾（～です、～だ、～よね等） * **词语选择：** 偏爱的词语、表达方式、专业术语使用频率 * **文章结构：** 句子长度、段落使用、连接词使用、逻辑展开 * **节奏感：** 标点符号使用、名词结尾（体言止め）频率 * **情感表达：** 积极/消极、情感表达方式、有无幽默感 * **习惯：** 特征性的表达方式、错别字倾向（如果有的话） **重要：** 请仅评估**写作风格**的相似性，而非主题或内容的正确性。 **输出格式：** 请按以下JSON格式返回评估结果。 * \\`similarityScore\\`: 请用 0.0（完全不像）到 1.0（看起来完全是同一个人）之间的**数值**来评估写作风格的相似度。 * \\`reason\\`: 请简要说明得到该分数的原因。特别是分数较低时，请指出您觉得哪些地方不同。 \\`\\`\\`json { \u0026#34;similarityScore\u0026#34;: number (0.0 ~ 1.0), \u0026#34;reason\u0026#34;: string } \\`\\`\\` --- **范本文章：** \\`\\`\\` ${originalText} \\`\\`\\` --- **AI生成的文章：** \\`\\`\\` ${generatedText} \\`\\`\\` --- 请按照上述格式，以JSON输出评估结果。 `; /** * 评估结果的类型定义（zod 模式） */ const SimilarityEvaluationSchema = z.object({ similarityScore: z.number().min(0).max(1).describe(\u0026#34;写作风格相似度分数（0.0 到 1.0）\u0026#34;), reason: z.string().describe(\u0026#34;评估理由\u0026#34;), }); type SimilarityEvaluation = z.infer\u0026lt;typeof SimilarityEvaluationSchema\u0026gt;; /** * 评估器（Judge）类 */ class AuthorshipSimilarityJudge extends MastraAgentJudge { constructor(model: LanguageModel) { super( \u0026#39;Authorship Similarity Judge\u0026#39;, \u0026#39;您是一位比较分析文章写作风格的专家。请按照给定的指示，评估两篇文章的相似度。\u0026#39;, model ); } async evaluate(originalText: string, generatedText: string): Promise\u0026lt;SimilarityEvaluation\u0026gt; { const prompt = generateSimilarityPrompt({ originalText, generatedText }); // 如果模型支持JSON模式或模式强制，则加以利用 try { const result = await this.agent.generate(prompt, { output: SimilarityEvaluationSchema }); return result.object; } catch (error) { console.error(\u0026#34;解析评估结果失败。将返回原始文本。\u0026#34;, error); // 回退：如果JSON解析失败，则视为分数0等 const fallbackResult = await this.agent.generate(prompt); return { similarityScore: 0.0, reason: `评估 AI 的输出格式不正确： ${fallbackResult.text}` }; } } } /** * 评估指标（Metric）类 */ interface AuthorshipSimilarityMetricResult extends MetricResult { info: SimilarityEvaluation; } class AuthorshipSimilarityMetric extends Metric { private judge: AuthorshipSimilarityJudge; constructor(model: LanguageModel) { super(); this.judge = new AuthorshipSimilarityJudge(model); } async measure(originalText: string, generatedText: string): Promise\u0026lt;AuthorshipSimilarityMetricResult\u0026gt; { const evaluationResult = await this.judge.evaluate(originalText, generatedText); return { score: evaluationResult.similarityScore, info: evaluationResult, }; } } // --- 工作流定义 --- const clonePromptGeneratorWorkflow = new Workflow({ name: \u0026#34;clone-prompt-generator-workflow-with-eval\u0026#34;, // 工作流名称 triggerSchema: z.object({ originalText: z.string().describe(\u0026#34;The original text written by the user to be cloned.\u0026#34;), }), }); // --- 步骤1：生成模仿指示提示 --- const generateClonePromptStep = new Step({ id: \u0026#34;generate-clone-prompt\u0026#34;, execute: async ({ context }) =\u0026gt; { const promptCreatorAgent = new Agent({ name: \u0026#39;Prompt Creator Agent\u0026#39;, instructions: ` # 指示：请创建最佳的“模仿文章生成提示” 您是提示工程师 AI。您的任务是分析给定的**【例文】**，准确把握其作者的**特征（人格、文风、习惯）**，并创建一个**通用的指示提示**，以便让其他 AI 模仿该作者生成**像人一样自然的**文章。 （省略... 提示的条件和思考过程不变） **那么，综合以上所有内容，请创建最佳的“模仿文章生成提示”。** ${feedbackForPromptCreator} `, model: llm, }); const originalText = context.triggerData.originalText; console.log(\u0026#34;[generate-clone-prompt] 开始生成提示。\u0026#34;); const result = await promptCreatorAgent.generate(` 【例文】: ${originalText} `); console.log(\u0026#34;[generate-clone-prompt] 提示生成完成。\u0026#34;); return `${result.text}`; }, }); // --- 最后步骤：输出成功的提示 --- const outputFinalPromptStep = new Step({ id: \u0026#34;output-final-prompt\u0026#34;, execute: async ({ context }) =\u0026gt; { const finalPrompt = context.getStepResult(generateClonePromptStep) as string; console.log(\u0026#34;--------------------------------------------------\u0026#34;); console.log(\u0026#34;工作流已完成！\u0026#34;); console.log(\u0026#34;成功的模仿指示提示：\u0026#34;); console.log(\u0026#34;--------------------------------------------------\u0026#34;); console.log(finalPrompt); // 在控制台输出最终提示 console.log(\u0026#34;--------------------------------------------------\u0026#34;); return finalPrompt; }, }); // --- 工作流组装 --- clonePromptGeneratorWorkflow .step(generateClonePromptStep) .until(async ({ context }) =\u0026gt; { // 接收 iteration iteration++; console.log(`\\n--- 循环 ${iteration} 开始 ---`); // 1. 获取生成的“模仿指示提示” const generatedClonePrompt = context.getStepResult(generateClonePromptStep) as string; const originalText = context.triggerData.originalText; // 2. 抽象化 originalText 的主题 const themeAbstractorAgent = new Agent({ name: \u0026#39;Theme Abstractor Agent\u0026#39;, instructions: ` 请分析给定文章的主要主题或话题，**避免使用具体的专有名词、产品名、技术名、服务名等**，用更通用、抽象的语言来表达。 输出请仅包含该抽象主题的说明文字，不要包含其他解说或前言。 示例：（省略...） `, model: llm, }); console.log(`[循环 ${iteration}] 正在从 originalText 抽象化主题...`); const abstractionResult = await themeAbstractorAgent.generate(` 请抽象化以下文章的主题：\\n---\\n${originalText}\\n--- `); const abstractedTheme = abstractionResult.text.trim(); console.log(`[循环 ${iteration}] 抽象化后的主题： ${abstractedTheme}`); // 3. 使用抽象化主题生成模仿文章 const textGeneratorAgent = new Agent({ name: \u0026#39;Text Generator Agent\u0026#39;, instructions: generatedClonePrompt, model: llm, }); console.log(`[循环 ${iteration}] 正在使用抽象化主题生成文章...`); const generatedTextResult = await textGeneratorAgent.generate( `请针对“${abstractedTheme}”，创建一篇即使是初学者也能容易理解的解说文章。` ); const generatedText = generatedTextResult.text; // 4. 评估相似度 console.log(`[循环 ${iteration}] 正在评估生成的文章与范本文章的相似度...`); const authorshipMetric = new AuthorshipSimilarityMetric(llm); // 使用评估指标 const metricResult = await authorshipMetric.measure( originalText, generatedText ); const currentScore = metricResult.score; const reason = metricResult.info.reason; console.log(`[循环 ${iteration}] 评估结果 - 分数： ${currentScore.toFixed(2)}, 理由： ${reason}`); // 5. 根据评估分数判断循环继续/结束 const shouldStop = currentScore \u0026gt;= SIMILARITY_THRESHOLD; if (!shouldStop) { feedbackForPromptCreator = ` --- **来自上次尝试的反馈（循环 ${iteration}）：** 使用生成的“模仿指示提示”让其书写关于“${abstractedTheme}”的内容后，与范本文章的相似度未达到目标（分数： ${currentScore.toFixed(2)}）。 评估 AI 指出了以下几点。请参考这些内容改进提示。 **失败的提示：** \\`\\`\\` ${generatedClonePrompt} \\`\\`\\` **评估 AI 的指正：** \\`\\`\\` ${reason} \\`\\`\\` --- `; console.log(`[循环 ${iteration}] 由于分数低于阈值，将创建反馈并重试。`); } else { console.log(`[循环 ${iteration}] 由于分数达到或超过阈值 (${SIMILARITY_THRESHOLD})，将结束循环。`); feedbackForPromptCreator = \u0026#34;\u0026#34;; // 成功后清除反馈 } console.log(`--- 循环 ${iteration} 结束 ---`); return shouldStop; // true 则结束循环，false 则继续 }, generateClonePromptStep) // 指定循环执行的步骤 .then(outputFinalPromptStep) // 指定循环结束后执行的步骤 .commit(); // 确定工作流定义 export { clonePromptGeneratorWorkflow }; 完成！“模仿指示提示”及其使用方法 最终输出\n当工作流顺利达到阈值以上的分数并结束后，最终完成的“模仿指示提示”将输出到终端控制台。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -------------------------------------------------- 工作流已完成！ 最终相似度分数： 0.75（示例） 成功的模仿指示提示： -------------------------------------------------- # 指示提示 您是一个 AI，需要模仿具有以下特征的人物，根据【文章内容】生成像人一样自然的文本。 ## 要模仿的人物特征： ### 人格： * 基本态度：礼貌且亲切。努力高效地传达信息。 * 说话方式：语气温和。也会使用像“～な感じです”这样的表达，但步骤说明很干练。 * 思维：逻辑性强但灵活。注重实践。 ...（以下是 AI 生成的提示内容）... -------------------------------------------------- 将这个输出的提示复制下来，活用到今后的文章生成中（例如，在 ChatGPT 或 Claude 等其他工具中使用时），应该就能让 AI 制作模仿您文风的草稿了！\n总结 这次我们使用 mastra 的循环功能和评估功能，尝试创建了一个工作流，让 AI 学习自己的写作风格，并自动生成和改进用于模仿该风格的提示本身。\n这是一个让 AI 思考如何使用 AI 的稍微有点元认知意味的方法，但如果顺利的话，应该能提高文章写作的效率吧。特别是对于那些想要用自己的风格写博客文章或报告，但又觉得打字很麻烦的人来说，这也许值得一试。\nmastra 真是一个相当有深度且有趣的库！大家也请务必尝试创建各种各样的工作流吧。\n","date":"2025-04-03T21:00:34+09:00","image":"https://takoyakisoft.com/p/build-llm-workflow-with-mastra/build-llm-workflow-with-mastra_hu_cd3ccd21a5d0f00f.webp","permalink":"https://takoyakisoft.com/zh-cn/p/build-llm-workflow-with-mastra/","title":"使用mastra自由定制LLM工作流！从Grok-2和think工具到文章克隆提示生成"},{"content":"你好！\n这次，我将分享一个尝试使用目前（截至2025年3月30日）可以免费使用的、性能非常强大的AI模型来开发简单Web游戏的故事。\n令人惊讶的是，Google 的 Gemini 2.5 Pro 实验模型（gemini-2.5-pro-exp-03-25）竟然可以在 ai.dev 网站上免费使用！据说这是目前性能最顶尖（SOTA）的模型之一，太厉害了！\n此外，我还试用了 ByteDance 公司 Trae 编辑器中的“Builder”功能（测试版）。在这里，可以使用像 Claude 一样的 AI 代理，并且可以选择“Claude 3.7 Sonnet”作为模型。这个也是免费的。\n不过，由于两者都是免费计划，输入的数据很可能会被用于服务改进等方面。因此，这不适合用于包含机密信息的开发，但对于要公开的程序或个人实验来说，可能非常合适！\n让 AI 制作 Three.js 游戏 那么，这次我尝试在这些强大 AI，特别是“Gemini 2.5 Pro”的帮助下，挑战制作一个仅使用单个 HTML 文件、基于 JavaScript 3D 库 Three.js 的游戏。\n我不仅仅是让它生成代码，为了让游戏更有趣，我向 AI 传达了“多汁感 (Juiciness)”的概念，并要求它进行了几次修改。“多汁感”指的是改善游戏体验的元素，例如操作时的舒适感和特效的华丽程度。\n完成的游戏 然后，完成的游戏就是这个！\n操作方法：\n移动鼠标光标可以移动相机视角。 点击鼠标发射子弹。 按 ESC 键可以退出操作焦点。 内容相当简单，但您或许能从鼠标操作的响应和效果中感受到一些“多汁感”。\n生成时间和注意事项 这个游戏实际上仅由一个 index.html 文件构成，代码行数达到了约 1500 行。\n使用 Gemini 2.5 Pro（gemini-2.5-pro-exp-03-25 模型）生成它，输出花费了大约 180 秒。相当耗时呢。\n根据这次经验，目前如果让 AI 生成单个文件的完整代码，将代码量控制在1000 行左右似乎是在合理时间内推进工作的较好选择。\n当然，这可能会根据模型的性能和拥堵情况而变化，但可以作为一个参考标准。\n总结 这次，我们介绍了使用免费的最新 AI 模型“Gemini 2.5 Pro”和“Trae Builder (Claude 3.7 Sonnet)”来生成 Three.js 游戏的尝试。\n能够免费使用性能如此强大的 AI 真是令人惊讶，根据不同的想法似乎可以创造出各种各样的东西！特别是对于计划公开的项目或学习目的而言，我认为这是非常有用的工具。\n虽然在代码生成时间等方面可能还有些不完善之处，但我认为这非常值得一试。\n非常感谢您读到这里！也请大家务必尝试一下。\n","date":"2025-03-30T23:43:05+09:00","image":"https://takoyakisoft.com/p/free-ai-models-create-threejs-game/free-ai-models-create-threejs-game_hu_6af50b4fb5b6c13f.webp","permalink":"https://takoyakisoft.com/zh-cn/p/free-ai-models-create-threejs-game/","title":"尝试使用最新的免费AI模型 Gemini 2.5 Pro 和 Trae Builder 开发 Three.js 游戏！"},{"content":"前言 你好！\n用Pygame制作的原创游戏，当然希望发布到Web上，让更多人玩到，对吧？我也是这么想的！\n在本文中，我们将一起探讨如何将使用Python游戏库 Pygame 制作的游戏发布到Web浏览器上，让任何人都能轻松玩到。我会尽量以简单易懂的方式进行解说。\n通过本文可以了解到：\n如何使用名为 pygbag 的工具，通过 WebAssembly (WASM) 将Pygame游戏转换（构建）为Web版本。这个工具相当方便。 将转换后的游戏嵌入到使用静态网站生成器 Hugo 创建的博客中并发布的步骤。 如何创建用于轻松将游戏嵌入文章的 Hugo 短代码 (Shortcode)。提前创建好这个会让后续工作轻松很多。 按照这个步骤，无需特殊的服务器设置，只需浏览器就能玩游戏了。很棒吧！你制作的游戏或许能让全世界的人玩到！\n完成的游戏 那么，实际用这种方法制作出来的就是这款游戏！ （这是一个只能观看的游戏。）\n将Pygame游戏构建为Web版本：尝试使用 pygbag 这个便捷工具 我认为 pygbag 是一个非常方便的工具，它可以将Pygame游戏打包，使其能直接在Web浏览器中运行。让我们先用它来将游戏转换为Web版本吧。\n1. 首先，使用 uv 准备项目 这里我们尝试使用 uv，一个最近备受关注的Python包管理工具。如果还没有安装 uv，请先安装。（如果你正在使用 pip 等其他工具，用你熟悉的工具也没问题）\n※ 安装 uv（如果尚未安装，此命令适用于Windows）\n1 powershell -ExecutionPolicy ByPass -c \u0026#34;irm https://astral.sh/uv/install.ps1 | iex\u0026#34; 接下来，使用 uv init 创建并初始化游戏项目的文件夹。 the-labyrinth-of-gaze 是本次示例中使用的游戏名称，请替换为您自己的项目名称。\n※ 使用 uv 初始化项目\n1 2 uv init the-labyrinth-of-gaze cd the-labyrinth-of-gaze 接下来，安装所需的库 pygbag 和 pygame。使用 uv 的命令如下：\n1 uv add pygbag pygame （如果不使用 uv，可以像 pip install pygbag pygame 这样，根据你的环境进行安装）\n2. 开始构建游戏 在通过 uv init 自动创建的 main.py 文件，或者你自己的游戏主脚本文件中，编写Pygame的游戏代码。\n本文示例中使用的游戏代码将在文末附上。\n准备就绪后，执行以下命令来构建Web版本的游戏。 请将 main.py 替换为你的游戏主脚本文件名。\n1 uv run pygbag --build .\\main.py 如果该命令成功执行，当前目录下应该会创建一个名为 build/web 的文件夹，其中包含用于在Web浏览器中运行游戏的文件（如 index.html、the-labyrinth-of-gaze.apk 等）。\n构建生成的文件示例如下: /game/the-labyrinth-of-gaze/build/web/index.html\n将游戏嵌入Hugo博客 接下来，让我们将构建好的游戏集成到Hugo博客中。 这里以 hugo-theme-stack 主题为例，但基本思路对于其他Hugo主题应该也是通用的。\n1. 关于游戏文件的存放位置 Hugo 有一个名为 static 的便捷文件夹，放入其中的文件和文件夹在构建网站时会被直接复制到网站的根目录（顶层）。我们将把刚才用 pygbag 生成的游戏文件放在这里。\n部署步骤（以游戏名 the-labyrinth-of-gaze 为例）：\n在Hugo项目根目录下的 static 文件夹中创建一个名为 game 的文件夹（如果不存在的话）。 在 static/game/ 文件夹内，再创建一个用于存放该游戏的文件夹（例如：the-labyrinth-of-gaze）。 将刚才由 pygbag 生成的 build/web 文件夹内部的所有文件复制到刚刚创建的 static/game/the-labyrinth-of-gaze/ 文件夹中。 注意： 这是关键点！请不要复制整个 build/web 文件夹，而是复制其内部的文件（如 index.html, the-labyrinth-of-gaze.apk 等）。 部署后的文件夹结构大致如下：\n1 2 3 4 5 6 7 8 9 (你的Hugo项目文件夹)/ └── static/ └── game/ └── the-labyrinth-of-gaze/ \u0026lt;-- 将构建结果复制到此文件夹 └── build/ └── web/ ├── index.html ├── the-labyrinth-of-gaze.apk └── (其他必要文件) ... 要点： 这样做之后，就可以通过类似 /game/the-labyrinth-of-gaze/build/web/index.html 这样的URL从网站访问游戏的 index.html 文件了。\n2. 每次都写 \u0026lt;iframe\u0026gt; 太麻烦了，让我们来创建Hugo短代码吧 Hugo 有一个名为 短代码 (Shortcode) 的便捷功能，我们可以利用它来轻松嵌入游戏。创建好这个之后，以后会非常方便。\n在Hugo项目的 layouts/shortcodes/ 文件夹中创建一个名为 game-iframe.html 的新文件，并将以下代码粘贴进去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 {{/* layouts/shortcodes/game-iframe.html */}} {{/* 通过 \u0026#39;src\u0026#39; 参数接收游戏URL */}} {{ $src := .Get \u0026#34;src\u0026#34; }} {{/* 通过 \u0026#39;aspect-ratio\u0026#39; 参数接收宽高比 (未指定则默认为 75% ≈ 4:3) */}} {{ $aspectRatio := .Get \u0026#34;aspect-ratio\u0026#34; | default \u0026#34;75%\u0026#34; }} {{/* 响应式 iframe 嵌入样式 */}} \u0026lt;div style=\u0026#34;position: relative; padding-bottom: {{ $aspectRatio }}; height: 0; overflow: hidden; max-width: 100%; height: auto;\u0026#34;\u0026gt; \u0026lt;iframe src=\u0026#34;{{ $src }}\u0026#34; style=\u0026#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 1px solid #ccc;\u0026#34; title=\u0026#34;Embedded Game\u0026#34; sandbox=\u0026#34;allow-scripts allow-same-origin allow-pointer-lock allow-fullscreen\u0026#34; loading=\u0026#34;lazy\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; 这个短代码的作用是：\n通过 src 参数接收想要嵌入的游戏的URL。 通过 aspect-ratio 参数可以指定游戏画面的显示比例（宽高比）（例如：75% 对应 4:3，56.25% 对应 16:9）。如果未指定，则默认设置为 75%（接近 4:3）。 它会使用 \u0026lt;iframe\u0026gt; 嵌入指定URL的内容，并且： 使用CSS进行调整，以确保在屏幕尺寸变化时布局不会混乱（即响应式设计）。 使用 sandbox 属性施加限制，使iframe中的内容运行更安全。 添加了 loading=\u0026quot;lazy\u0026quot; 属性，延迟加载iframe直到其接近可视区域，这是一个小优化，可以略微加快页面加载速度。 3. 好了，准备就绪！让我们在文章中使用它吧 至此准备工作完成！打开你想介绍游戏的那篇文章的Markdown文件，尝试使用刚才创建的短代码吧。\n例如，创建一个类似 content/posts/my-pygame-game.md 的文章文件，在正文中像这样写入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- title: \u0026#34;公开自制Pygame游戏“凝视迷宫”！\u0026#34; # 文章标题 date: 2025-03-28T00:00:00+09:00 description: \u0026#34;发布了用Pygame和pygbag制作的迷宫游戏。可以在浏览器中轻松游玩！\u0026#34; # 文章描述 slug: the-labyrinth-of-gaze-game # 文章slug（URL的一部分） image: the-labyrinth-of-gaze.webp # 封面图片 categories: [\u0026#34;游戏\u0026#34;] # 分类 tags: [\u0026#34;Pygame\u0026#34;, \u0026#34;自制游戏\u0026#34;, \u0026#34;解谜\u0026#34;] # 标签 draft: false --- 我尝试将用Pygame制作的“凝视迷宫”游戏发布到Web上了！ 使用 `pygbag` 就能像这样嵌入到博客中，真方便！ 请一定在浏览器中轻松体验一下。 {{\u0026lt; game-iframe src=\u0026#34;/game/the-labyrinth-of-gaze/build/web/index.html\u0026#34; aspect-ratio=\u0026#34;75%\u0026#34; \u0026gt;}} 操作方法： * （请在这里具体写上游戏的操作方法等） * 例如：方向键移动，空格键跳跃 等 游戏说明： （建议在这里写上游戏的规则、目标、看点等） 如果你能乐在其中，我会很高兴！ 这里的要点是：\n在 {{\u0026lt; ... \u0026gt;}} 中间写入刚才创建的短代码名称 game-iframe。 对于 src 参数，需要指定刚才放在 static 文件夹中的游戏 index.html 文件在网站上的绝对路径（以 / 开头的路径）。 例如：如果文件放在 static/game/the-labyrinth-of-gaze/build/web/index.html，则应写为 /game/the-labyrinth-of-gaze/build/web/index.html。 重要： 这里很容易出错，请注意！请根据你的游戏实际存放位置，正确填写此路径。 建议根据你的游戏画面调整 aspect-ratio 参数，以获得更好的视觉效果（例如：16:9 对应 56.25%）。 在短代码下方，当然可以自由地写上操作方法、游戏说明等内容。 完成这些之后，只需使用 hugo 命令构建并发布网站，游戏应该就会嵌入并显示在文章中了！\n总结 本次，我们介绍了使用便捷工具 pygbag 将 Pygame 游戏转换为 WebAssembly (WASM)，将其部署到 Hugo 博客的 static 文件夹，并创建 用于 iframe 嵌入的 Hugo 短代码 以便在文章中轻松显示游戏的完整步骤。\n我个人认为这种方法的优点在于：\n无需特殊服务器配置！ 仅用静态文件就能发布游戏，非常方便快捷。 能够轻松地在博客文章中添加互动游戏，是不是很令人兴奋？ 为你制作的 Pygame 游戏提供了让更多人玩到的机会！ 对于访问者来说，无需任何浏览器插件就能立刻开始玩，这也是一个优点。 如果你正在使用 Pygame 制作游戏，并且想“尝试发布到 Web 上”，不妨参考这个步骤挑战一下。\n感谢您阅读到最后！\n源代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 # 使用 Pygame 的 A* 算法迷宫寻路动画（自动进行和效果添加/修正版） import pygame import random import heapq import math import time # 为计算 dt 添加（即使没有，clock.tick 也可以） # --- 常量 --- # 网格设置 GRID_WIDTH = 31 GRID_HEIGHT = 25 CELL_SIZE = 15 MARGIN = 1 # 窗口大小 WINDOW_WIDTH = GRID_WIDTH * (CELL_SIZE + MARGIN) + MARGIN WINDOW_HEIGHT = GRID_HEIGHT * (CELL_SIZE + MARGIN) + MARGIN # 颜色 (RGB) - 更新为现代配色方案 WHITE = (245, 245, 245) BLACK = (20, 20, 30) GREY = (180, 180, 180) GREEN = (76, 187, 23) RED = (235, 64, 52) BLUE = (66, 135, 245) YELLOW = (250, 204, 21) CYAN = (28, 186, 210) ORANGE = (255, 126, 28) LIGHT_ORANGE = (255, 183, 77) # 用于闪烁 PATH_HIGHLIGHT = (130, 210, 240) # 浅蓝色（路径显示动画用） PATH_HIGHLIGHT_PULSE = (180, 230, 250) # 用于脉冲效果 GOAL_FLASH = (255, 255, 255) # 目标到达时效果用 HOVER_COLOR = (220, 220, 220) # 用于悬停效果 PURPLE = (180, 120, 240) # 新颜色 PINK = (255, 105, 180) # 新颜色 # 动画速度 (Frame Per Second) FPS = 60 # 自动重置前的等待时间（秒） RESET_DELAY_SECONDS = 2.0 # 路径高亮动画速度（每帧移动的格子数，越小越慢） PATH_HIGHLIGHT_SPEED = 0.3 # --- 辅助函数（无更改） --- def heuristic(a, b): (r1, c1) = a (r2, c2) = b return abs(r1 - r2) + abs(c1 - c2) def get_valid_neighbors(node, grid): neighbors = [] row, col = node rows = len(grid) cols = len(grid[0]) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] for dr, dc in directions: nr, nc = row + dr, col + dc if 0 \u0026lt;= nr \u0026lt; rows and 0 \u0026lt;= nc \u0026lt; cols and grid[nr][nc] == 0: neighbors.append((nr, nc)) return neighbors def reconstruct_path(came_from, current): path = [] while current in came_from: path.append(current) current = came_from[current] path.reverse() return path def generate_maze(width, height): grid = [[1 for _ in range(width)] for _ in range(height)] start_r, start_c = random.randrange(1, height, 2), random.randrange(1, width, 2) grid[start_r][start_c] = 0 stack = [(start_r, start_c)] visited = {(start_r, start_c)} while stack: cr, cc = stack[-1] neighbors = [] for dr, dc in [(0, 2), (0, -2), (2, 0), (-2, 0)]: nr, nc = cr + dr, cc + dc if 0 \u0026lt; nr \u0026lt; height - 1 and 0 \u0026lt; nc \u0026lt; width - 1 and (nr, nc) not in visited: neighbors.append((nr, nc)) if neighbors: nr, nc = random.choice(neighbors) grid[(cr + nr) // 2][(cc + nc) // 2] = 0 grid[nr][nc] = 0 visited.add((nr, nc)) stack.append((nr, nc)) else: stack.pop() passages = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0] if len(passages) \u0026lt; 2: start_node = (1, 1) if height \u0026gt; 1 and width \u0026gt; 1 else (0, 0) end_node = (height - 2, width - 2) if height \u0026gt; 2 and width \u0026gt; 2 else start_node if grid[start_node[0]][start_node[1]] == 1: grid[start_node[0]][start_node[1]] = 0 if grid[end_node[0]][end_node[1]] == 1: grid[end_node[0]][end_node[1]] = 0 else: start_node = random.choice(passages) end_node = random.choice(passages) while end_node == start_node: end_node = random.choice(passages) return grid, start_node, end_node # 粒子类定义 - 改进以支持更多样化的效果 class Particle: def __init__(self, x, y, color, particle_type=\u0026#34;normal\u0026#34;): self.x = x self.y = y self.base_color = color # 保留原始颜色 self.color = color self.particle_type = particle_type self.size = ( random.randint(2, 6) if particle_type == \u0026#34;normal\u0026#34; else random.randint(3, 8) ) self.speed = ( random.uniform(1, 5) * 50 # 速度调整（基于 dt） if particle_type == \u0026#34;normal\u0026#34; else random.uniform(0.5, 3) * 50 # 速度调整（基于 dt） ) self.angle = random.uniform(0, math.pi * 2) self.lifespan = ( random.uniform(0.5, 1.5) if particle_type == \u0026#34;normal\u0026#34; else random.uniform(1.0, 2.5) ) self.age = 0 self.pulse_rate = random.uniform(3.0, 6.0) # 用于脉冲效果 self.original_size = self.size # 用于尺寸变化 self.fade_in_duration = 0.3 # 淡入时间 self.fade_out_start_ratio = 0.7 # 从寿命的百分之多少开始淡出 # 星形粒子的顶点数 self.vertices = random.randint(4, 6) if particle_type == \u0026#34;star\u0026#34; else 0 # 用于轨迹粒子 self.trail = [] self.trail_length = 5 if particle_type == \u0026#34;trail\u0026#34; else 0 # 用于波纹效果 if particle_type == \u0026#34;ripple\u0026#34;: self.size = 1 self.max_size = random.randint(15, 25) self.expand_speed = random.uniform(0.8, 1.2) * 30 # 速度调整（基于 dt） self.lifespan = random.uniform(1.0, 1.5) self.speed = 0 # 波纹不移动 def update(self, dt): self.x += math.cos(self.angle) * self.speed * dt self.y += math.sin(self.angle) * self.speed * dt self.age += dt # 根据粒子类型进行更新处理 size_decay_rate = self.original_size / (self.lifespan * (1.0 - self.fade_out_start_ratio)) if self.lifespan \u0026gt; 0 else 1 if self.particle_type == \u0026#34;normal\u0026#34;: if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: self.size = max(0, self.size - size_decay_rate * dt) elif self.particle_type == \u0026#34;pulse\u0026#34;: pulse = math.sin(self.age * self.pulse_rate) * 0.5 + 0.5 current_size_factor = 1.0 if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: current_size_factor = max(0, 1 - (self.age - self.lifespan * self.fade_out_start_ratio) / (self.lifespan * (1.0 - self.fade_out_start_ratio))) self.size = self.original_size * (0.5 + pulse * 0.5) * current_size_factor elif self.particle_type == \u0026#34;fade_in\u0026#34;: if self.age \u0026lt; self.fade_in_duration: self.size = self.original_size * (self.age / self.fade_in_duration) elif self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: fade_out_duration = self.lifespan * (1.0 - self.fade_out_start_ratio) self.size = max(0, self.original_size * (1 - (self.age - self.lifespan * self.fade_out_start_ratio) / fade_out_duration)) else: self.size = self.original_size # 淡入后、淡出前为最大尺寸 elif self.particle_type == \u0026#34;trail\u0026#34;: self.trail.append((self.x, self.y)) if len(self.trail) \u0026gt; self.trail_length: self.trail.pop(0) if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: self.size = max(0, self.size - size_decay_rate * dt * 0.5) # Trail 消失得稍慢一些 elif self.particle_type == \u0026#34;ripple\u0026#34;: self.size = min(self.size + self.expand_speed * dt, self.max_size) elif self.particle_type == \u0026#34;star\u0026#34;: if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: self.size = max(0, self.size - size_decay_rate * dt) else: # default or rainbow etc. if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: self.size = max(0, self.size - size_decay_rate * dt) # 颜色变化（色相随时间变化 - rainbow 类型） if self.particle_type == \u0026#34;rainbow\u0026#34;: hue_shift = (self.age * 100) % 360 # HSV -\u0026gt; RGB 转换（简化版） r_val, g_val, b_val = 0, 0, 0 i = int(hue_shift / 60) % 6 f = hue_shift / 60 - i v = 1.0 # 亮度 s = 1.0 # 饱和度 p = v * (1 - s) q = v * (1 - f * s) t = v * (1 - (1 - f) * s) if i == 0: r_val, g_val, b_val = v, t, p elif i == 1: r_val, g_val, b_val = q, v, p elif i == 2: r_val, g_val, b_val = p, v, t elif i == 3: r_val, g_val, b_val = p, q, v elif i == 4: r_val, g_val, b_val = t, p, v elif i == 5: r_val, g_val, b_val = v, p, q self.color = (int(r_val*255), int(g_val*255), int(b_val*255)) def draw(self, surface): if self.size \u0026lt;= 0: # 如果尺寸小于等于 0 则不绘制 return # 淡入/淡出效果的透明度计算 alpha = 255 if self.particle_type == \u0026#34;ripple\u0026#34;: # 波纹效果的透明度计算（逐渐变淡） progress = self.age / self.lifespan if self.lifespan \u0026gt; 0 else 1 alpha = max(0, min(255, int(255 * (1 - progress) * 0.8))) # 结尾时更加透明 elif self.particle_type == \u0026#34;fade_in\u0026#34;: if self.age \u0026lt; self.fade_in_duration: alpha = int(255 * (self.age / self.fade_in_duration)) elif self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: fade_out_duration = self.lifespan * (1.0 - self.fade_out_start_ratio) if fade_out_duration \u0026gt; 0: alpha = max(0, min(255, int(255 * (1 - (self.age - self.lifespan * self.fade_out_start_ratio) / fade_out_duration)))) else: alpha = 0 # 以防万一 else: alpha = 255 else: # Normal, Pulse, Star, Trail, Rainbow etc. # 通用的淡出处理 if self.age \u0026gt;= self.lifespan * self.fade_out_start_ratio: fade_out_duration = self.lifespan * (1.0 - self.fade_out_start_ratio) if fade_out_duration \u0026gt; 0: alpha = max(0, min(255, int(255 * (1 - (self.age - self.lifespan * self.fade_out_start_ratio) / fade_out_duration)))) else: alpha = 0 else: alpha = 255 # 颜色验证和设置 try: current_color = self.color if self.particle_type == \u0026#34;rainbow\u0026#34; else self.base_color if isinstance(current_color, tuple) and len(current_color) == 3: r = max(0, min(255, int(current_color[0]))) g = max(0, min(255, int(current_color[1]))) b = max(0, min(255, int(current_color[2]))) final_color = (r, g, b, alpha) else: final_color = (255, 255, 255, alpha) # 默认颜色 # 根据粒子类型绘制 if self.particle_type == \u0026#34;ripple\u0026#34;: # 波纹效果（绘制轮廓） line_width = max(1, int(self.max_size / 15 * (1 - self.age / self.lifespan))) # 逐渐变细的轮廓 if self.size \u0026gt;= 1: # 最小半径大于等于 1 pygame.draw.circle(surface, final_color, (int(self.x), int(self.y)), int(self.size), width=line_width) elif self.particle_type == \u0026#34;star\u0026#34; and self.vertices \u0026gt; 0: # 星形粒子 points = [] outer_radius = self.size inner_radius = self.size * 0.4 for i in range(self.vertices * 2): angle = math.pi / self.vertices * i - math.pi / 2 # 调整使顶点朝上 radius = outer_radius if i % 2 == 0 else inner_radius x_p = self.x + math.cos(angle) * radius y_p = self.y + math.sin(angle) * radius points.append((x_p, y_p)) if len(points) \u0026gt;= 3: # 至少需要 3 个点 pygame.draw.polygon(surface, final_color, points) elif self.particle_type == \u0026#34;trail\u0026#34; and len(self.trail) \u0026gt; 1: # 轨迹粒子 for i in range(len(self.trail) - 1): start_pos = self.trail[i] end_pos = self.trail[i + 1] # 调整轨迹的 alpha 和宽度 trail_alpha = alpha * ((i + 1) / len(self.trail))**2 # 越往后越淡 trail_width = max(1, int(self.size * ((i + 1) / len(self.trail)))) trail_color_tuple = (final_color[0], final_color[1], final_color[2], int(trail_alpha)) pygame.draw.line(surface, trail_color_tuple, start_pos, end_pos, trail_width) # 也绘制前端的圆 pygame.draw.circle(surface, final_color, (int(self.x), int(self.y)), int(self.size)) else: # 普通圆形粒子 (Normal, Pulse, Fade_in, Rainbow) pygame.draw.circle(surface, final_color, (int(self.x), int(self.y)), int(self.size)) except (ValueError, TypeError) as e: # 如果发生错误，则使用默认颜色 print(f\u0026#34;Error drawing particle: {e}, color={self.color}, alpha={alpha}, size={self.size}\u0026#34;) try: safe_color = (255, 255, 255, alpha) if self.size \u0026gt;= 1: pygame.draw.circle(surface, safe_color, (int(self.x), int(self.y)), int(max(1, self.size))) # 保证最小尺寸为 1 except Exception as final_e: print(f\u0026#34;Final fallback drawing failed: {final_e}\u0026#34;) # --- Pygame 初始化 --- pygame.init() screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT)) pygame.display.set_caption(\u0026#34;A* Maze Solver Animation (Auto-Repeat, ESC: Quit)\u0026#34;) clock = pygame.time.Clock() font = pygame.font.Font(None, 24) # --- 状态变量 --- grid = [] start_node = None end_node = None open_set_heap = [] open_set_map = {} closed_set = set() came_from = {} g_score = {} path = [] current_node = None solving = False maze_generated = False message = \u0026#34;\u0026#34; particles = [] # 粒子列表（ripples 也合并到这里） # ripples = [] # 因为不再需要而删除 node_pulses = [] # 用于节点搜索时的脉冲效果（目前可能未使用？） # --- 自动重置用变量 --- reset_timer = 0 # 等待帧计数器 RESET_DELAY_FRAMES = int(RESET_DELAY_SECONDS * FPS) # 将秒转换为帧数 start_reset_timer_after_highlight = False # 高亮完成后启动计时器的标志 # --- 路径高亮动画用变量 --- path_highlight_index = 0.0 # 使用 float 缓慢前进 highlighting_path = False # --- 目标到达效果用 --- goal_reached_flash = False # 是否是到达目标后的那一帧 # --- 主循环 --- running = True frame_count = 0 # 用于闪烁动画 hover_cell = None # 悬停中的单元格 while running: # --- Delta Time 计算 --- dt = clock.tick(FPS) / 1000.0 # 以秒为单位的 delta time（避免除以 0） if dt == 0: dt = 1 / FPS # 保证最小时间步长 # --- 事件处理 --- for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if event.type == pygame.KEYDOWN: if event.key == pygame.K_ESCAPE: running = False # 从鼠标坐标获取悬停中的单元格 mouse_pos = pygame.mouse.get_pos() mouse_col = mouse_pos[0] // (CELL_SIZE + MARGIN) mouse_row = mouse_pos[1] // (CELL_SIZE + MARGIN) if 0 \u0026lt;= mouse_row \u0026lt; GRID_HEIGHT and 0 \u0026lt;= mouse_col \u0026lt; GRID_WIDTH: hover_cell = (mouse_row, mouse_col) else: hover_cell = None # --- 状态更新 --- if not maze_generated: # 重置等待计时器 reset_timer = 0 start_reset_timer_after_highlight = False highlighting_path = False path_highlight_index = 0.0 goal_reached_flash = False hover_cell = None particles = [] # 清除现有粒子 message = \u0026#34;正在生成新迷宫...\u0026#34; screen.fill(BLACK) msg_render = font.render(message, True, WHITE) screen.blit(msg_render, (10, WINDOW_HEIGHT // 2 - 10)) pygame.display.flip() grid, start_node, end_node = generate_maze(GRID_WIDTH, GRID_HEIGHT) open_set_heap = [] open_set_map = {} closed_set = set() came_from = {} path = [] current_node = None g_score = { (r, c): float(\u0026#34;inf\u0026#34;) for r in range(GRID_HEIGHT) for c in range(GRID_WIDTH) } if start_node: # 确认 start_node 不为 None g_score[start_node] = 0 h_start = heuristic(start_node, end_node) if end_node else 0 f_start = g_score[start_node] + h_start heapq.heappush(open_set_heap, (f_start, h_start, start_node)) open_set_map[start_node] = (f_start, h_start) maze_generated = True solving = True if start_node and end_node else False # 如果没有开始/结束节点则不求解 message = \u0026#34;正在求解...\u0026#34; if solving else \u0026#34;迷宫已生成（没有起点/终点？）\u0026#34; # --- A* 算法的步进执行 --- if solving and open_set_heap: current_f, current_h, current_node_popped = heapq.heappop(open_set_heap) # 如果已从 open_set_map 中删除，或者之后找到了更好的路径，则跳过 if current_node_popped not in open_set_map or open_set_map[current_node_popped] \u0026gt; (current_f, current_h): pass # 忽略并进入下一个循环 else: # 因为要处理，所以从 open_set_map 中删除（可能再次添加） # 因为在从 heapq 弹出时就作为处理对象，所以 del 可能不需要。重复检查在上面的 if 中进行。 # del open_set_map[current_node_popped] # 此处的删除可能不需要 current_node = current_node_popped if current_node == end_node: path = reconstruct_path(came_from, current_node) solving = False message = \u0026#34;已到达目标！正在高亮路径...\u0026#34; current_node = None highlighting_path = True path_highlight_index = 0.0 goal_reached_flash = True # 打开效果生成标志 start_reset_timer_after_highlight = True else: closed_set.add(current_node) # 确认从 open_set_map 中删除（因为它已进入 closed） if current_node in open_set_map: del open_set_map[current_node] # 为正在搜索的节点添加波纹效果 node_x = (current_node[1] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 node_y = (current_node[0] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 # 生成波纹效果（使用 Particle 类） particles.append(Particle(node_x, node_y, YELLOW, \u0026#34;ripple\u0026#34;)) # 将颜色更改为 YELLOW # 少量生成小粒子（搜索时） if random.random() \u0026lt; 0.1: # 稍微降低概率 for _ in range(1): # 减少数量 color = random.choice([YELLOW, ORANGE]) # 使颜色与搜索颜色匹配 particles.append(Particle(node_x, node_y, color, \u0026#34;fade_in\u0026#34;)) for neighbor in get_valid_neighbors(current_node, grid): if neighbor in closed_set: continue tentative_g_score = g_score[current_node] + 1 # 如果此路径不如现有路径，或者 open set 中已有更好的路径，则忽略 # 注意：open_set_map 中存储的是 (f, h) neighbor_in_open = open_set_map.get(neighbor) if neighbor_in_open and tentative_g_score \u0026gt;= g_score.get(neighbor, float(\u0026#39;inf\u0026#39;)): continue # 如果找到更好的路径，或者首次访问 came_from[neighbor] = current_node g_score[neighbor] = tentative_g_score h_neighbor = heuristic(neighbor, end_node) f_neighbor = tentative_g_score + h_neighbor # 如果不在 open_set 中则添加，如果存在则更新（heapq 不直接支持更新，因此添加新元素） heapq.heappush(open_set_heap, (f_neighbor, h_neighbor, neighbor)) open_set_map[neighbor] = (f_neighbor, h_neighbor) # 保存 f, h elif solving and not open_set_heap: solving = False message = f\u0026#34;未找到路径！将在 {RESET_DELAY_SECONDS:.1f} 秒后重置...\u0026#34; current_node = None reset_timer = RESET_DELAY_FRAMES # 搜索失败时立即启动计时器 # --- 路径高亮处理 --- if highlighting_path and path: if path_highlight_index \u0026lt; len(path): path_highlight_index += PATH_HIGHLIGHT_SPEED * FPS * dt # 使用 dt 调整速度 # 完成瞬间的处理 if path_highlight_index \u0026gt;= len(path): path_highlight_index = len(path) if start_reset_timer_after_highlight: reset_timer = RESET_DELAY_FRAMES message = f\u0026#34;路径完成！将在 {RESET_DELAY_SECONDS:.1f} 秒后重置...\u0026#34; start_reset_timer_after_highlight = False # --- 自动重置计时器处理 --- if reset_timer \u0026gt; 0: reset_timer -= 1 # 基于帧进行倒计时 remaining_time = reset_timer / FPS # 转换为秒并显示 if not solving and not path: message = f\u0026#34;未找到路径！将在 {remaining_time:.1f} 秒后重置...\u0026#34; elif not solving and path and path_highlight_index \u0026gt;= len(path): message = f\u0026#34;路径完成！将在 {remaining_time:.1f} 秒后重置...\u0026#34; if reset_timer \u0026lt;= 0: maze_generated = False # --- 绘制处理 --- # 渐变背景 for y in range(WINDOW_HEIGHT): time_factor = math.sin(frame_count * 0.005) * 0.2 r_base = 30 + int(10 * time_factor) g_base = 40 + int(15 * time_factor) b_base = 60 + int(20 * time_factor) gradient_factor = math.sin(math.pi * y / WINDOW_HEIGHT) r = int(r_base + (50 - r_base) * gradient_factor) # 稍微调暗 g = int(g_base + (70 - g_base) * gradient_factor) # 稍微调暗 b = int(b_base + (90 - b_base) * gradient_factor) # 稍微调暗 pygame.draw.line(screen, (max(0,r), max(0,g), max(0,b)), (0, y), (WINDOW_WIDTH, y)) # 提升单元格质感（阴影和光泽）- 这部分保持原样也可以 shadow_surface = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT), pygame.SRCALPHA) for row in range(GRID_HEIGHT): for col in range(GRID_WIDTH): rect = pygame.Rect( (MARGIN + CELL_SIZE) * col + MARGIN, (MARGIN + CELL_SIZE) * row + MARGIN, CELL_SIZE, CELL_SIZE, ) if grid[row][col] == 0: # 通道 pygame.draw.rect(shadow_surface, (0, 0, 0, 30), rect.inflate(1, 1), border_radius=3) # 稍微浅一点的阴影 light_rect = rect.inflate(-3, -3).move(-1, -1) pygame.draw.rect(shadow_surface, (255, 255, 255, 50), light_rect, border_radius=2) # 光泽也稍微低调一点 else: # 墙壁 pygame.draw.rect(shadow_surface, (0, 0, 0, 20), rect.inflate(1, 1), border_radius=2) pygame.draw.rect(shadow_surface, (0, 0, 0, 30), rect.inflate(-2, -2), border_radius=1, width=1) # 内部阴影 screen.blit(shadow_surface, (0, 0)) # 到达目标时的粒子生成 if goal_reached_flash: goal_x = (end_node[1] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 goal_y = (end_node[0] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 # 生成多种粒子类型 for _ in range(40): # 增加普通粒子数量 color = random.choice([RED, YELLOW, ORANGE, BLUE, GREEN, PURPLE, PINK, WHITE]) particles.append(Particle(goal_x, goal_y, color, \u0026#34;normal\u0026#34;)) for _ in range(15): # 增加星形粒子数量 color = random.choice([YELLOW, WHITE, ORANGE, CYAN]) particles.append(Particle(goal_x, goal_y, color, \u0026#34;star\u0026#34;)) for _ in range(10): # 脉冲效果 color = random.choice([CYAN, PURPLE, PINK, BLUE]) particles.append(Particle(goal_x, goal_y, color, \u0026#34;pulse\u0026#34;)) for _ in range(8): # 轨迹粒子 color = random.choice([BLUE, CYAN, WHITE, GREEN]) particles.append(Particle(goal_x, goal_y, color, \u0026#34;trail\u0026#34;)) for _ in range(10): # 彩虹粒子 particles.append(Particle(goal_x, goal_y, WHITE, \u0026#34;rainbow\u0026#34;)) # 初始颜色为白色即可 for _ in range(6): # 波纹效果也作为 Particle 生成 color = random.choice([WHITE, CYAN, BLUE, YELLOW]) # 波纹颜色 particles.append(Particle(goal_x, goal_y, color, \u0026#34;ripple\u0026#34;)) # 以 ripple 类型生成 goal_reached_flash = False # ★★★ 粒子生成后立即重置标志 ★★★ # 单元格绘制循环 for row in range(GRID_HEIGHT): for col in range(GRID_WIDTH): color = WHITE if grid[row][col] == 1: color = BLACK node = (row, col) is_path_node = False # 是否为路径高亮对象的标志 # --- 根据单元格状态设置颜色 --- if node in closed_set: # closed 列表的颜色（已搜索）- 稍暗的 CYAN color = (20, 140, 160) # 存在于 open_set_map 中的节点（搜索候选）- 稍暗的 YELLOW # 即使 heapq 中有多个相同节点，open_set_map 中也应该包含最新的 (f, h) if node in open_set_map: color = (200, 160, 10) # 稍暗的 YELLOW # --- 路径高亮 --- if highlighting_path and path: current_path_segment_index = int(path_highlight_index) if node in path[:current_path_segment_index]: is_path_node = True pulse_factor = math.sin(frame_count * 0.15 + path.index(node) * 0.1) * 0.5 + 0.5 # 根据节点位置进行相位偏移 r = int(PATH_HIGHLIGHT[0] + (PATH_HIGHLIGHT_PULSE[0] - PATH_HIGHLIGHT[0]) * pulse_factor) g = int(PATH_HIGHLIGHT[1] + (PATH_HIGHLIGHT_PULSE[1] - PATH_HIGHLIGHT[1]) * pulse_factor) b = int(PATH_HIGHLIGHT[2] + (PATH_HIGHLIGHT_PULSE[2] - PATH_HIGHLIGHT[2]) * pulse_factor) color = (r, g, b) # 前端节点的效果 if current_path_segment_index \u0026lt; len(path) and node == path[current_path_segment_index - 1]: if (frame_count // 4) % 2 == 0: # 调整闪烁速度 color = PATH_HIGHLIGHT_PULSE # 在前端生成粒子（低概率） if random.random() \u0026lt; 0.15: # 稍微提高概率 x = (node[1] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 y = (node[0] * (CELL_SIZE + MARGIN)) + MARGIN + CELL_SIZE // 2 particles.append(Particle(x, y, PATH_HIGHLIGHT_PULSE, \u0026#34;fade_in\u0026#34;)) # 匹配颜色 # --- 当前搜索中的节点 --- if solving and node == current_node: # 闪烁效果 if (frame_count // 8) % 2 == 0: # 调整闪烁速度 color = LIGHT_ORANGE else: color = ORANGE # --- 开始和目标 --- if node == start_node: color = GREEN elif node == end_node: # 到达目标后的闪光不由 goal_reached_flash 标志管理， # 也可以考虑其他方法，例如仅在 highlighting_path 变为 True 的最初几帧调亮 # 目前保持简单的 RED color = RED # --- 单元格绘制 --- rect = pygame.Rect( (MARGIN + CELL_SIZE) * col + MARGIN, (MARGIN + CELL_SIZE) * row + MARGIN, CELL_SIZE, CELL_SIZE, ) pygame.draw.rect(screen, color, rect, border_radius=3) # --- 光泽和悬停效果 --- is_floor_like = (grid[row][col] == 0 or node == start_node or node == end_node or node in open_set_map or node in closed_set or is_path_node) if is_floor_like: # 光泽 highlight_rect = rect.copy() highlight_rect.height = max(1, CELL_SIZE // 4) # 稍微小一点 highlight_color = (min(255, color[0] + 40), min(255, color[1] + 40), min(255, color[2] + 40)) pygame.draw.rect(screen, highlight_color, highlight_rect, border_top_left_radius=3, border_top_right_radius=3) # 悬停 if hover_cell == node: hover_rect = rect.inflate(-1, -1) # 避免与边框重叠 hover_color = HOVER_COLOR # 固定颜色可能更容易理解 # pygame.draw.rect(screen, hover_color, hover_rect, border_radius=2) # 填充 pygame.draw.rect(screen, hover_color, hover_rect, width=1, border_radius=2) # 用边框显示 # --- 边界线 --- border_color = (max(0, color[0] - 50), max(0, color[1] - 50), max(0, color[2] - 50)) # 更暗 pygame.draw.rect(screen, border_color, rect, 1, border_radius=3) frame_count += 1 # 在这里递增 frame_count # --- 粒子更新和绘制 --- active_particles = [] for p in particles: p.update(dt) # 传递 dt 进行更新 # 根据寿命和尺寸（或波纹达到最大尺寸）判断生存 is_alive = p.age \u0026lt; p.lifespan if p.particle_type == \u0026#34;ripple\u0026#34;: # 波纹寿命结束后消失（即使达到 max_size 也会继续移动） pass else: # 普通粒子尺寸变为 0 后消失 is_alive = is_alive and p.size \u0026gt; 0 if is_alive: active_particles.append(p) particles = active_particles # 只保留有效的粒子 # 创建用于粒子绘制的透明 Surface # 使用 SRCALPHA 可以正确处理每个粒子的 alpha 值（透明度） particle_surface = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT), pygame.SRCALPHA) for p in particles: p.draw(particle_surface) # 在透明 Surface 上绘制 # 在 screen（已绘制背景和单元格）上叠加绘制 particle_surface screen.blit(particle_surface, (0, 0)) # --- 消息显示 --- if message: text_color = WHITE stroke_color = BLACK msg_render = font.render(message, True, text_color) # 描边绘制 for dx, dy in [(-1,-1), (-1,1), (1,-1), (1,1), (-1,0), (1,0), (0,-1), (0,1)]: stroke_render = font.render(message, True, stroke_color) screen.blit(stroke_render, (10 + dx, WINDOW_HEIGHT - 25 + dy)) # 主体文本绘制 screen.blit(msg_render, (10, WINDOW_HEIGHT - 25)) # --- 画面更新 --- pygame.display.flip() # goal_reached_flash 的重置移至粒子生成后立即进行 # --- 结束处理 --- pygame.quit() ","date":"2025-03-30T05:18:12+09:00","image":"https://takoyakisoft.com/p/publish-pygame-web-hugo-pygbag/publish-pygame-web-hugo-pygbag_hu_5faf9495e623c6de.webp","permalink":"https://takoyakisoft.com/zh-cn/p/publish-pygame-web-hugo-pygbag/","title":"发布你的Pygame游戏到Web！使用pygbag和Hugo轻松嵌入博客 (WebAssembly)"},{"content":"如何支付5美元给xAI并每月获得150美元的积分 我参考了以下文章注册了xAI：\nGrok API：支付5美元即可使用150美元的额度？\n首先，访问 xAI Cloud Console。\n按图中1、2的顺序点击，输入“Billing address”（账单地址）。\n图片仅为示例，我用英文填写。地址应与您的信用卡地址一致。\n“Tax ID Type”（税务ID类型）和“Tax Number”（税务号码）是可选的，我没有填写。\n这可能与税收有关，但我不太确定。\n接下来，输入“Payment methods”（支付方式）。\n我使用的是PayPay的JCB卡，支付成功。（注：PayPay是日本流行的支付服务，但任何有效的信用卡都应该可以。在中国，您可以使用常见的信用卡或支持国际支付的其他方式。）\n有一个“Redeem Promo code”（兑换促销代码）的输入框，但截至2月20日，即使使用xAI的DeepResearch工具也找不到任何促销代码。可能目前没有可用的代码。\n点击“Purchase credits”（购买积分）来购买积分。\n支付5美元即可。支付后，会出现“Share Data”（共享数据）按钮（我忘记截图了）。\n根据这篇文章，同意与xAI共享数据后，每月可以获得150美元的积分：\n每月获得150美元的免费API积分\n在VSCode扩展中使用xAI的方法 在Cody中使用Grok API Cody: AI Code Assistant 是一个AI驱动的扩展，提供代码补全、编辑和聊天功能。\n代码补全始终免费，但代码编辑和聊天有使用次数限制。通过为编辑和聊天设置Grok API，您只需支付5美元即可无限制地使用AI编码功能。\n如图所示，点击“文件”→“首选项”→“设置”，然后点击右上角的图标打开“settings.json”。\n或者，按“Ctrl” + “Shift” + P 并选择“Preferences: Open Settings (JSON)”。\n以下是如何在\u0026quot;cody.dev.models\u0026quot;中设置您想要添加的模型。由于Grok是OpenAI兼容的API，因此将提供商指定为\u0026quot;openai\u0026quot;。\n此外，我还设置了DeepSeek和Gemini API。DeepSeek也是一种价格实惠的API，您可以使用它。\nGemini是Google提供的API，可以免费使用。（由于连续使用有一定的限制，我使用了多个实例。）\n对于\u0026quot;inputTokens\u0026quot;、\u0026quot;temperature\u0026quot;和\u0026quot;stream\u0026quot;，我直接使用了官方示例中的设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \u0026#34;cody.dev.models\u0026#34;: [ { \u0026#34;provider\u0026#34;: \u0026#34;openai\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;grok-2-latest\u0026#34;, \u0026#34;inputTokens\u0026#34;: 131072, \u0026#34;outputTokens\u0026#34;: 8192, \u0026#34;apiKey\u0026#34;: \u0026#34;xai-xxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;temperature\u0026#34;: 0, \u0026#34;stream\u0026#34;: false }, \u0026#34;apiEndpoint\u0026#34;: \u0026#34;https://api.x.ai/v1\u0026#34; }, { \u0026#34;provider\u0026#34;: \u0026#34;groq\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;deepseek-chat\u0026#34;, \u0026#34;inputTokens\u0026#34;: 128000, \u0026#34;outputTokens\u0026#34;: 8192, \u0026#34;apiKey\u0026#34;: \u0026#34;sk-xxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;temperature\u0026#34;: 0.6 }, \u0026#34;apiEndpoint\u0026#34;: \u0026#34;https://api.deepseek.com/chat/completions\u0026#34; }, { \u0026#34;provider\u0026#34;: \u0026#34;google\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;gemini-2.0-pro-exp-02-05\u0026#34;, \u0026#34;inputTokens\u0026#34;: 2097152, \u0026#34;outputTokens\u0026#34;: 8192, \u0026#34;apiKey\u0026#34;: \u0026#34;AIxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;temperature\u0026#34;: 1.0 } }, { \u0026#34;provider\u0026#34;: \u0026#34;google\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;gemini-2.0-flash-exp\u0026#34;, \u0026#34;inputTokens\u0026#34;: 1048576, \u0026#34;outputTokens\u0026#34;: 8192, \u0026#34;apiKey\u0026#34;: \u0026#34;AIxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;temperature\u0026#34;: 1.0 } } ], \u0026#34;cody.edit.preInstruction\u0026#34;: \u0026#34;Please think thoughts in English. 输出应为中文。\u0026#34;, \u0026#34;cody.chat.preInstruction\u0026#34;: \u0026#34;Please think thoughts in English. 输出应为中文。\u0026#34; } 在代码编辑（\u0026ldquo;cody.edit.preInstruction\u0026rdquo;）和聊天（\u0026ldquo;cody.chat.preInstruction\u0026rdquo;）中，您可以设置类似于ChatGPT中的自定义提示。\n在Cline中使用Grok API Cline 似乎是一个AI代理。它可以读写文件、新建文件以及执行命令。由于它与API进行多次交互，因此会消耗大量令牌。\nCline 可以通过如图所示的“OpenAI Compatible”选项进行设置。设置完成后，点击“Done”保存。\n在Roo Code中使用Grok API Roo Code（前身为Roo Cline） 是Cline的一个分支，提供更快的更新和更多功能。\nRoo Code 也可以通过如图所示的“OpenAI Compatible”选项进行设置。设置完成后，点击“Done”保存。\n","date":"2025-02-20T00:00:00+09:00","image":"https://takoyakisoft.com/p/registering-xai-grok-api-and-using-it-with-vscode-extensions-cody-cline-roo-code/xai_payment_hu_caf0b26686df4180.webp","permalink":"https://takoyakisoft.com/zh-cn/p/registering-xai-grok-api-and-using-it-with-vscode-extensions-cody-cline-roo-code/","title":"注册xAI（Grok API）并在VSCode扩展（Cody、Cline、Roo Code）中使用"},{"content":"YouTube视频 【免费】用谷歌翻译完整翻译电子书PDF！ 谷歌翻译 请访问以下网址使用谷歌翻译： https://translate.google.co.jp/\n可以翻译图片。\n谷歌翻译会用背景色遮盖原文，然后在其上显示翻译后的文本。 点击“下载译文”即可下载翻译后的图片。\n超过 10MB 或 300 页的文件无法翻译。 支持以下文件格式：\n.docx .pdf .pptx .xlsx PDFsam Basic 请访问以下网址下载 PDFsam Basic： https://pdfsam.org/download-pdfsam-basic/ 我们下载了“Portable archive”版本。\n启动时似乎会进行 Java 设置，请通过“pdfsam.bat”文件启动。\n当文件大小超过 10MB 时使用此功能。 建议将“分割大小”设置为 5.6MB。 这是因为以 10MB 分割时，谷歌翻译出现了超时错误。\n当页数超过 300 页时使用此功能。 将“每隔 n 页分割”设置为 300。 如果出现超时，请尝试将数值降低至 200 或 100。\n如图所示，将分割后的 PDF 文件拖放到此处。\n点击“运行”进行合并。合并后的文件会使用默认文件名，需要进行重命名。\nPDFsam Visual 由于只有 14 天的试用期，因此不推荐使用。 但是，由于其对纯文本 PDF 的压缩率很高，这里也进行介绍。\n请访问以下网址下载 PDFsam Visual： https://pdfsam.org/download-pdfsam-visual/ 我们下载了“Portable archive 64-bit”版本。\n在启动画面中选择“Compress”。\n将 PDF 文件拖放到此处。\n通过“BROWSE”选择保存目标文件夹，然后点击“SAVE”进行压缩。\niLovePDF 请访问以下网址使用 iLovePDF 的“压缩 PDF”功能： https://www.ilovepdf.com/ja/compress_pdf\n将 PDF 文件拖放到此处。\n选择“推荐压缩”或“极限压缩”，然后点击“压缩PDF”。\n","date":"2024-11-24T17:00:00+09:00","image":"https://takoyakisoft.com/p/free-translate-entire-ebook-pdfs-with-google-translate/free-translate-entire-ebook-pdfs-with-google-translate_hu_6e991b2d48c69724.webp","permalink":"https://takoyakisoft.com/zh-cn/p/free-translate-entire-ebook-pdfs-with-google-translate/","title":"【免费】用谷歌翻译完整翻译电子书PDF！"},{"content":"YouTube 视频 【Steam Link】在笔记本电脑上远程畅玩 Minecraft！ 在笔记本电脑上进行操作（安装 Steam Link 客户端） 从以下 URL 下载 Steam Link： https://store.steampowered.com/remoteplay\n从此图片所示位置下载适合你操作系统的 Steam Link 版本。\nSteam Link 支持以下操作系统：\niPhone、iPad、Apple TV（11.0 或更高版本） Android（5.0 或更高版本）手机、平板电脑和电视 无法访问 Google Play 的 Android 用户 Raspberry Pi 3、3+、4 Windows Linux macOS Meta Quest 2、3、Pro 对于 Windows 系统，建议使用 setup.exe 文件进行安装，而不是 msi 文件。它还会检查你的电脑环境是否缺少所需的软件。\n安装过程中一直点击“下一步”即可。\n在游戏 PC 上进行操作（安装 Steam 主机端） 点击“Steam” -\u0026gt; “设置” -\u0026gt; “远程畅玩” -\u0026gt; 将“启用远程畅玩”切换为开启状态。\n点击“游戏” -\u0026gt; “将非 Steam 游戏添加到库中” -\u0026gt; “浏览”，然后添加 Minecraft 启动器。在我的环境中，它位于 D 盘：“D:\\XboxGames\\Minecraft Launcher\\Content\\gamelaunchhelper.exe”。 打开后，确保选中“gamelaunchhelper”，然后点击“添加所选程序”。\n从笔记本电脑进行远程畅玩（Steam Link 客户端） 请确保笔记本电脑上的 Steam 已关闭。它会干扰连接。\n启动 Steam Link。 如果防火墙提示，请允许访问。 第一次连接时，你可能需要在游戏 PC 上点击“确定”按钮。\n鼠标光标可能不会显示。将备用鼠标连接到游戏 PC 可以解决此问题。或者，如果你使用的是 Windows 11 专业版，登录和注销远程桌面会话也可以使光标显示。\n建议在 Minecraft 设置中禁用原始鼠标输入。原因是在打开和关闭箱子时移动鼠标光标可能会导致视角向该方向移动。禁用原始鼠标输入应该可以解决此问题。\n","date":"2024-11-20T17:00:00+09:00","image":"https://takoyakisoft.com/p/steam-link-play-minecraft-remotely-smooth-gameplay-on-your-laptop/steam-link-play-minecraft-remotely-smooth-gameplay-on-your-laptop_hu_b0d1360ca7a52d1c.webp","permalink":"https://takoyakisoft.com/zh-cn/p/steam-link-play-minecraft-remotely-smooth-gameplay-on-your-laptop/","title":"【Steam Link】在笔记本电脑上远程畅玩 Minecraft！"}]